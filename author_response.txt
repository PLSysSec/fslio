Author response CSF '14
=======================

Review 3

> What about "normal" programs?
> Can you prove a permissiveness theorem?

In the related work section, we describe how to encode no-sensitive-upgrades
in our flow-sensitive (FS) calculus. As a result, we can say that it is (at
least) as permissive as no-sensitive-upgrades. With respect to our own work,
our FS calculus is as permissive as flow-insensitive (FI) LIO. Any FI LIO
program can be trivially converted to a FS LIO program (without auto-upgrades)
by using flow-sensitive references instead of flow-insensitive ones. Since these
references would never be upgraded, they will behave just like their
flow-insensitive counterparts.

As an example of a "normal" program that could be run in our flow-sensitive
monitor, we note the case of GitStar, a code-hosting web platform that uses FI
LIO as its backend [Giffin2012]. GitStar's core could be run in our
flow-sensitive monitor; the full system uses other features like privileges and
exceptions that we have not directly implemented in this version of the
flow-sensitive monitor, but we see no major challenges in incorporating
flow-sensitivity to the full version of LIO.

(maybe we could add a short description of Deian's new use case as
another example?)

Review 4

> What would be the major challenges in
> proving correctness of the semantics mechanically?

We see no major problems with writing mechanised proofs for our
results in a proof assistant. We have already gotten some experience 
encoding part of the FI LIO proofs into Coq [CoqLIO]. 


References
----------

[Giffin2012] Daniel B. Giffin, Amit Levy, Deian Stefan, David Terei,
David Mazi√®res, John Mitchell, Alejandro Russo . Hails: Protecting
Data Privacy in Untrusted Web Applications. In Proceedings of 10th
Symposium on Operating Systems Design and Implementation (OSDI) ,
USENIX . 2012.

[CoqLIO] https://github.com/deian/lio-semantics

