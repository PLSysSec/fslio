\section{Introduction}
\label{sec:intro}

%% Information-flow control as a promising technology 
Information-flow control (IFC) emerges as a promising technology to preserve
confidentiality and integrity of data in presence of untrusted code.  In
particular, it has become attractive for web 
applications~\citep[e.g.][]{DeGroef:2012:FWB:2382196.2382275, giffin:hails,
  yang:2013:towards, conf/esorics/AkhaweLHSS13, Hedin13} and mobile phone
platforms ~\citep[e.g.][]{Enck:2010,android:esorics13}, where the challenge is
to allow untrusted code to access confidential information while restricting its
manipulation.

% Intro to non-interference 
IFC focus on preventing, or limiting, leaks of secret data into public
channels. When no leaks are desired, the chosen baseline policy is
\emph{non-interference}~\citep{Goguen:Meseguer:Noninterference}, which 
essentially demands no dependence of public events on secrets. In scenarios where
non-interference is a strong policy, means for declassification, or intended
release of information, are introduced~\citep{Sabelfeld:Sands:CSFW05}. In this
article, we focus on \emph{non-interference}. 

%% Language-based enforcement 
Recently, it has become popular to provide language-based IFC enforcements in
the form of execution monitors~\citep{Hedin2011}. This decision is mainly
motivated by (i) the permissiveness of dynamic techniques over static
ones~\citep{Sabelfeld:Russo:PSI09}, and (ii) the simplicity for treating notions
like dynamic code evaluation---a feature commonly present in modern scripting
languages. To fulfill confidentiality demands, IFC monitors maintain a
mapping from variables to security labels~\citep{myers:dlm,Stefan:2011}.  
For simplicity of exposition, we consider only two labels: |high| (high), which
denotes secrets, and |low| (low), which denotes public data. The partial ordering
|low canFlowTo high| and |high cantFlowTo low| expresses that information
can only flow from public data into secret entities.

%% Treatment of variables 
%% Definition flow-sensitive, flow-insensitive 
One of the facets to IFC analysis lies in the treatment of
variables~\citep{Hunt:2006}. Some analyzes, called \emph{flow-insensitive},
forbid variables to change its security labels at execution time, i.e., labels
are treated as \emph{immutable}. In contrast, \emph{flow-sensitive} enforcements
admit changes on labels to reflect the confidentiality of the stored data, i.e.,
labels are considered as \emph{mutable}. For instance, assuming variable |h|,
with security level |high|, variable |l|, with security levels |low|, and
function |publish(v)|, which produces a public event of value |v|, the program
|P = h := l ; publish(h)| is accepted by such an enforcement. The reason for
that is the change of |h|'s label, which becomes |low| after
the assignment (|h := l|).

%Although static flow-sensitive and flow-insensitive analysis are
%equivalent in expressiveness (module code rewriting)~\citep{Hunt:2006}, the 
%situation is not as clear for purely dynamic analysis.

%% Why one instead of the other one 
%%%%% FS+ Permissiveness in dynamic approaches, limited resources, 
Flow-sensitive analyzes are beneficial for different reasons. In presence of
scarce resources, for instance CPU registers, it is not feasible to think that
they will be assigned a fixed security label throughout program
execution~\citep{BonelliCM05}. More importantly, flow-sensitivity analyses often
boost permissiveness by leveraging the changes on labels to reduce the number of
rejected programs (recall program $P$ above). 


%% Problems with Flow-sensitivity and purely dynamic IFC
Unfortunately, purely dynamic IFC
systems can turn label changes into a covert channel~\citep{Russo:2010}. 
\begin{wrapfigure}{r}{0.5\columnwidth}
|l := 1 ; t := 0 ;| \\
|if h then t := 1;| \\
|if t /= 1 then l := 0| \\
|publish(l)| 
\caption{\small\label{fig:fsattackintro} Flow-sensitive attack}
\end{wrapfigure}
Figure \ref{fig:fsattackintro} illustrates the problem of enabling arbitrary
label changes.  In the attack, variables |l| and |h| do not change their
security levels---|low| and |high|, respectively. In contrast, variable |t| can
change its security level to |high|. For purely dynamic monitors, where
non-taken branches are not inspected, the attack succeed to leak information
about |h|. More precisely, when |h| is true, the initial labels for |l| and |t|
are |low| since they initially store constants (|l :=1 ; t := 0|).  Due to 
the assignment |t := 1| inside the
first |then|-branch (which depends on |h|), the value of |t| changes to |1| and its label to
|high|. The condition of the second branch is not fulfill and therefore 
the monitor executes |publish(l)|, which produces the public event 
|1|. On the other hand, when |h| is false, variable |t| is not relabeled to 
|high|, i.e., the first |then|-branch is not taken. Instead, the second
|then|-branch is executed. 
The assignment |l := 0| does not change the label of |l| but its value to 
 |0|. Observe that the assignment is determined by public data (|t /= 1|)
and the assigned value is a constant. Finally, the monitor executes
|publish(l)|, which produces the public event |0|. As a result, the monitor 
missed to catch the information leak about |h|.  

To close this covert channel, there exists mainly three different proposals:
incorporate some static analysis/information into the execution
monitor~\citep{Russo:2010,stefan:lio,10.1109/SP.2013.10}, forbid certain label
changes ---a policy known as \emph{no-sensitive
  upgrades}~\citep{Austin:Flanagan:PLAS10}---, and deny branches on certain
variables which have mutated their labels---a policy named \emph{permissive
  upgrades}~\citep{Austin:Flanagan:PLAS10}. All of these solutions are proposed
for sequential programming languages.


%% Operating system community
Before the time of language-based techniques for IFC, the operating system
community has traditionally handle the problem inherent to combine mutable
labels and purely dynamic monitors. Modern examples of that are the operating
systems Asbestos~\citep{Efstathopoulos:2005}, HiStar~\citep{zeldovich:histar},
and Flume~\citep{krohn:flume}. In a nutshell, those systems are composed of
subjects (e.g. processes) and objects (e.g. files or sockets) with security
labels. While security labels for objects are immutable, labels for subjects can
be changed---often by a more restrictive one. Making label changes implicit
(e.g. as a result of observing data from objects) is known as
\emph{tainting}. Subjects' labels restrict read and write actions in order to
preserve confidentiality. For instance, if a process reads a file labeled as
|high|, it gets tainted and its label becomes |high|, which makes it unable to
write into public files. As before, changing labels might become a covert
channel itself. To avoid it, HiStar and Flume require label changes to be done
explicitly.  Asbestos, on the other hand, allows changes in security labels as
the result of receiving messages under specific and safe conditions. Different
form language-based approaches, OS work rarely comes with soundness guarantees
(except for~\citep{Krohn,seL4IF}). Bare in mind that an operating system is not
a simple piece of software to prove correct.


%% LIO brings together OS and LB  
LIO is a IFC system that brings ideas from the OS domain into a language-based
setting~\citep{stefan:lio,stefan:addressing-covert}.  LIO is a floating-label
system, where the label of a computation can be safely raised to accommodate
reading sensitive data. This action can be seen as raising the program counter
(\emph{pc}) in more traditional language-based
systems~\citep{sabelfeld:language-based-iflow} or as tainting in secure OS.  In
this light, it is not surprising that LIO treats objects (e.g. references,
synchronization variables, etc.) as flow-insensitive entities. Different from
other IFC tools~\citep{jif,FlowCaml,Hedin13}, LIO allows programs to query
objects' labels without affecting the floating-label---a useful feature to
increase permissiveness when interacting with external databases~\citep{giffin:hails}.

%% Contributions 
%Inspired by previous results~\citep{Austin:Flanagan:PLAS10}, 
In this paper, we adapt LIO to work with flow-sensitive entities.  
%For pure and
%immutable flow-sensitive values (e.g. booleans or functions), we propose to
%taint the floating-label with the labels of the values being
%inspected---regardless if it is their labels or content what is under scrutiny.
We present a calculus which treats almost uniformly flow-insensitive and
flow-sensitive mutable references. The novelty in the calculus is to consider
the labels as being composed of two elements: a label describing the
confidentiality of the stored value, and another label, called \emph{the label
  on the label}, which describes the confidentiality of the value's
label. Having this model, we forbid to change a label of a reference if
\emph{the label on the label is below the floating-label} (similar to the {\nsu}
discipline~\citep{Austin:Flanagan:PLAS10}). Inspired by~\citep{Hedin13}, we add
an instruction capable to upgrade labels under certain safe conditions. However,
different from Hedin et al., our upgrade operation \emph{does not
  fail}. Instead, it taints the floating-label with the label on the label
regardless the success of the operation. This different is crucial to scale our
approach for concurrency, where the termination channel should not be
neglected~\citep{stefan:addressing-covert}. To reduce the programmer's burden to
introduce upgrade annotations, the calculus provides means for automatically
upgrade references at safe points, i.e., when the floating-label gets tainted.
While secure, this feature facilitates label creep, i.e., all flow-sensitive
references might end up with ``too high'' labels. To address that, we
propose a block-structured primitive which only upgrades the labels of
declared flow-sensitive references, while forbidden the access to undeclared
ones.
% using flow-sensitive entities without permanently tainting the floating label,
% but enforcing their destruction after the execution of the block.
%To guarantee
%non-interference, we demand the floating-label to get permanently tainted with
%the label corresponding to the flow-sensitive objects  
% We
%present two mechanisms to mitigate this problem: an explicitly change labels
%w(inspired by \citep{Hedin13}), and a 
%On the other 
%hand, in a concurrent setting, we simply adapt the {\nsu} policy to work with
%LIO. 
% We argue, by showing an attack, that {\nsu} is the most
% permissive policy for scenarios where actions are forbidden by the monitor based on threads'
% local data---an essential requirement to obtain performance and
% scalability.
More concretely, the contribution of this paper are as follows.
\begin{itemize}

\item An extension to incorporate flow-sensitive entities in LIO. As a result,
  not only increases LIO its permissiveness, but it also provides means for safely
  combining flow-insensitive and flow-sensitive references. 

\item An uniform mechanisms to treat flow-insensitive and flow-sensitive
  references in either a sequential or concurrent setting. To the best of our
  knowledge, we are the first ones to analyze the challenges of purely dynamic
  monitors with flow-sensitive references in presence of concurrency.

\item Provably non-interference. Our formal results are developed for arbitrary
  security lattices. 

% \item An implementation of our ideas in Haskell, where programmers can write
%   routines \emph{parametric} on the flow-sensitivity of data---a novelty for IFC
%   tools. 
\end{itemize}

Although developed for LIO, we believe that our approaches for the sequential
and concurrent settings might be applied to other language-based floating-label
systems~\citep[e.g.][]{10.1109/SP.2013.10} as well as IFC OS work.

% Local Variables:
% TeX-master: "main.tex"
% TeX-command-default: "Make"
% End:
