\section{Introduction}
\label{sec:intro}

%% Information-flow control as a promising technology 
Information-flow control (IFC) is a promising approach to preserving
confidentiality and integrity of data in the presence of untrusted code.  In
particular, it has become attractive for web 
applications (e.g.,\cite{DeGroef:2012:FWB:2382196.2382275, giffin:hails,
  yang:2013:towards, conf/esorics/AkhaweLHSS13, Hedin13}) and mobile phone
platforms (e.g., \cite{Enck:2010,android:esorics13}), where the challenge is
to allow untrusted code to access confidential information while restricting its
manipulation.

% Intro to non-interference 
In its simplest form the role of IFC is to prevent (or bound) the leaking of
sensitive, or secret, data into public channel.  When no leaks are desired, the
chosen baseline policy is
\emph{non-interference}~\cite{Goguen:Meseguer:Noninterference}, which
essentially demands that there be no dependence between public events and
secrets. In scenarios where non-interference is too restricting, means for
declassification, or intended release of information, are
introduced~\cite{Sabelfeld:Sands:CSFW05}. In this article, we focus on
\emph{non-interference}. 

%% Language-based enforcement 
Recently, it has become popular to provide language-based IFC enforcements in
the form of execution monitors~\cite{Hedin2011}. This decision is mainly
motivated by (i) the permissiveness of dynamic techniques over static
ones~\cite{Sabelfeld:Russo:PSI09}, and (ii) the simplicity for treating notions
like dynamic code evaluation---a feature commonly present in modern scripting
languages. To fulfill confidentiality demands, IFC monitors maintain a
mapping from variables to security labels~\cite{myers:dlm,Stefan:2011}.  
Without loss of generality, in this paper, we consider only two labels: |high|
(high), which denotes secret, and |low| (low), which denotes public data. The
partial ordering |low canFlowTo high| and |high cantFlowTo low| expresses that
information can only flow from public data into secret entities.

%% Treatment of variables 
%% Definition flow-sensitive, flow-insensitive 
One of the facets of IFC analysis lies in the treatment of
variables~\cite{Hunt:2006}. Some system, known as \emph{flow-insensitive},
prevent variables from changing their security labels at execution time, i.e., labels
are treated as \emph{immutable}. In contrast, \emph{flow-sensitive} systems
allow changes on labels to reflect the confidentiality of the stored data, i.e.,
labels \emph{mutable} according to the data stored in them.
Consider, for instance, program |P @= h := l ; publish(h)|, where variables |h| and |l| respectively have labels |H| and |L|, and
function |publish(v)| that writes value |v| to a public channel.
%
While flow-insensitive systems do not permit this program since it appears as if
we are leaking |h| into a public channel (at the point of |publish(h)|), |P| is
a valid program in the more-permissive flow-sensitive systems: |h|'s label
changes from |H| to |L| after the assignment (|h := l|), thus allowing the value
to be published to a public channel. As shown by this example, flow-sensitive
analyses are capable of boosting permissiveness by leveraging the changes on labels
in order to reduce the number of
rejected programs. %(recall program |P| above).


%Although static flow-sensitive and flow-insensitive analysis are
%equivalent in expressiveness (module code rewriting)~\citep{Hunt:2006}, the 
%situation is not as clear for purely dynamic analysis.

%% Why one instead of the other one 
%%%%% FS+ Permissiveness in dynamic approaches, limited resources, 
%Flow-sensitive analyses are useful in many scenarios. When considering scarce
%resources (e.g., CPU registers) it is not feasible to assume that each
%reference will be assigned a fixed security label throughout program
%execution~\cite{BonelliCM05}. 


%% Problems with Flow-sensitivity and purely dynamic IFC
\begin{wrapfigure}{r}{0.55\columnwidth}
|l := 1 ; t := 0 ;| \\
|if h then t := 1;| \\
|if t /= 1 then l := 0| \\
|publish(l)| 
\caption{\small\label{fig:fsattackintro} Flow-sensitive attack}
\end{wrapfigure}
Unfortunately, the introduction of flow-sensitive references to purely dynamic IFC
systems can turn label changes into a covert channel~\cite{Russo:2010}. 
Figure \ref{fig:fsattackintro} illustrates the problem of allowing arbitrary
label changes.  In the attack, variables |l| and |h| do not change their
security levels, which are respectively |low| and |high|. In contrast, variable |t|
changes its security level to |high| from |low|. For purely dynamic monitors, where
non-taken branches are not inspected, the attack successfully leaks information
about |h|. More precisely, when |h| is true, the initial labels for |l| and |t|
are |low| since they initially store constants (|l :=1 ; t := 0|).  Due to 
the assignment |t := 1| inside the
first |then|-branch (which depends on |h|), the value of |t| changes to |1| and its label to
|high|. The condition of the second branch does not hold and therefore 
the monitor executes |publish(l)|, which produces the public event 
|1|. On the other hand, when |h| is false, variable |t| is not relabeled to 
|high|, i.e., the first |then|-branch is not taken. Instead, the second
|then|-branch is executed. 
The assignment |l := 0| does not change the label of |l| but its value to 
 |0|. Observe that the assignment is determined by public data (|t /= 1|)
and the assigned value is a constant. Finally, the monitor executes
|publish(l)|, which produces the public event |0|. As a result, the monitor 
missed to catch the information leak about |h|.  

To close this covert channel, there have been three main approaches:
incorporate some static analysis/information into the execution
monitor~\cite{Russo:2010,stefan:lio,10.1109/SP.2013.10}; forbid certain label
changes, a policy known as \emph{no-sensitive
  upgrades}\Red{, first proposed by Zdancewic~\cite{Zdancewic02programminglanguages} and named by Austin and Flanagan~\cite{Austin:Flanagan:PLAS09}}
; and, deny branches on certain
variables which have mutated their labels, a policy named \emph{permissive
  upgrades}~\cite{Austin:Flanagan:PLAS10}. All of these solutions are proposed
for sequential programming languages.


%% Operating system community
The operating system IFC
community has also handled the problem inherent to combining mutable
labels and purely dynamic monitors. Modern examples of this are
Asbestos~\cite{Efstathopoulos:2005}, HiStar~\cite{zeldovich:histar},
and Flume~\cite{krohn:flume}. In a nutshell, these systems are composed of
subjects, i.e., processes, and objects (e.g., files or sockets) with security
labels. While security labels for objects are immutable, labels for subjects can
be changed---usually to more restrictive ones. This changing of the subject label 
is commonly referred to as ``tainting.''
%
The subjects' labels restrict read and write actions in order to
preserve confidentiality. For instance, if a process reads a file labeled as
|high|, it gets tainted and its label becomes |high|, which prevents it from subsequently
writing to public files. As in the language case, changing labels can become a covert
channel itself, if not handled accordingly. To avoid it, HiStar and Flume require label changes to be done
explicitly.  Asbestos, on the other hand, allowed changes in security labels as
the result of receiving messages under specific and safe conditions.


%% LIO brings together OS and LB  
LIO is an IFC system that brings ideas from the operating systems domain into a language-based
setting~\cite{stefan:lio,stefan:addressing-covert}.  LIO is a floating-label
system, where the label of a computation can be safely raised to accommodate
reading sensitive data. This action can be seen as raising the program counter
(\emph{pc}) in more traditional language-based
systems~\cite{sabelfeld:language-based-iflow} or as tainting in IFC OSes.  In
this light, it is not surprising that LIO treats objects (e.g., references,
synchronization variables, etc.) as flow-insensitive entities. Different from
other IFC tools~\cite{jif,FlowCaml,Hedin13}, LIO allows programs to query
objects' labels without affecting the floating-label---a useful feature to
increase permissiveness when interacting building practical systems~\cite{giffin:hails}.

%% Contributions 
%Inspired by previous results~\citep{Austin:Flanagan:PLAS10}, 
In this paper, we extend the calculus for LIO in order to work with
flow-sensitive references.
%For pure and
%immutable flow-sensitive values (e.g. booleans or functions), we propose to
%taint the floating-label with the labels of the values being
%inspected---regardless if it is their labels or content what is under scrutiny.
%We present a calculus which treats almost uniformly flow-insensitive and
%flow-sensitive mutable references. 
The novelty in the calculus is to consider labels of references as being composed of two
elements: a label describing the confidentiality of the stored value, and
another label, called \emph{the label on the label}, which describes the
confidentiality of the value's label. The calculus then forbids changing a
label of a reference if \emph{the label on the label is below the
  floating-label} (similar to the {\nsu}
discipline).%Austin:Flanagan:PLAS10})
Inspired by~\cite{Hedin13}, we add
a primitive for \emph{upgrading} labels under certain safe conditions in
order to boost permissiveness. As one of our main insights and results, we prove
that the {\nsu} policy and upgrade operations can be already expressed using
flow-insensitive concepts---the key idea being the ability have nested labeled
values.  
Our sequential semantics for flow-sensitive references directly extend to the
concurrent setting, for which the termination channel must not be
neglected~\cite{stefan:addressing-covert}.

To reduce the programmer's burden of
introducing upgrade annotations, the calculus provides means for automatically
upgrading references at safe points, i.e., when the floating-label gets tainted.
While secure, this feature facilitates label creep, i.e., all flow-sensitive
references might end up with ``too high'' labels. To further address this, we propose a
block-structured primitive which only upgrades the labels of declared
flow-sensitive references, while disallowing access to undeclared ones.
% using flow-sensitive entities without permanently tainting the floating label,
% but enforcing their destruction after the execution of the block.
%To guarantee
%non-interference, we demand the floating-label to get permanently tainted with
%the label corresponding to the flow-sensitive objects  
% We
%present two mechanisms to mitigate this problem: an explicitly change labels
%w(inspired by \citep{Hedin13}), and a 
%On the other 
%hand, in a concurrent setting, we simply adapt the {\nsu} policy to work with
%LIO. 
% We argue, by showing an attack, that {\nsu} is the most
% permissive policy for scenarios where actions are forbidden by the monitor based on threads'
% local data---an essential requirement to obtain performance and
% scalability.
More concretely, the contributions of this paper are:
\begin{itemize}

\item An extension to incorporate flow-sensitive entities in LIO. This
  not only increases LIO's permissiveness, but also provides means for safely
  combining flow-insensitive and flow-sensitive references.

\item A uniform mechanism to treat flow-insensitive and flow-sensitive
  references in either a sequential or concurrent setting. To the best of our
  knowledge, we are the first ones to analyze the challenges of purely dynamic
  monitors with flow-sensitive references in the presence of concurrency.

\item Provable non-interference for arbitrary security lattices.

% \item An implementation of our ideas in Haskell, where programmers can write
%   routines \emph{parametric} on the flow-sensitivity of data---a novelty for IFC
%   tools. 
\end{itemize}
%
Although developed for LIO, we believe that our results generalize to other
sequential and concurrent settings floating-label systems (e.g.,
\cite{10.1109/SP.2013.10, Efstathopoulos:2005, zeldovich:histar, krohn:flume}).

\hl{Structure of the paper, i.e., the paper is organized as follows}
% Local Variables:
% TeX-master: "main.tex"
% TeX-command-default: "Make"
% End:
