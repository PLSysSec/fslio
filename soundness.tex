\section{Formal results}
\label{sec:soundness}

In this section, we show that our flow-sensitive enforcement can be
embedded into the flow-insensitive version of LIO. Additionally, we
provide security guarantees in terms of non-interference by reusing
previous results about LIO.

\subsection{Embedding into \lio{}}

We will now show that we can implement our flow-sensitive semantics in
terms of flow-insensitive references. More concretely, every
flow-sensitive reference stored as |LabeledTCB l_o (LabeledTCB l_d
v)|, can be represented by a flow-insensitive reference with label
|l_o|, whose contents are the labeled value |LabeledTCB l_d v|.

Figure~\ref{fig:fs-exts-semantics-impl} shows our implementation of
the flow-sensitive reference operations in this setting.  For a given
store |c|, we define the |impl (-) (c)| function, which given a term
|t| in \liofs{}, produces a term |impl (t) (c)| in \lio{}, which is
obtained by expanding the definitions of flow-sensitive operations in
terms of flow-insensitive ones. This function is applied
homomorphically in all other cases. We use the tag |WrapRef| to mark
the flow-insensitive references that are being used to represent
flow-sensitive ones, so as to distinguish them from ordinary
flow-insensitive references. The functions |wrap| and |unwrap| are
used to add and remove this tag. For the sake of brevity, we do not
explain this mapping in detail, but we remark that it is directly
based on the rules in Figure~\ref{fig:sos:fs}.

\begin{figure}
\small
\begin{code}
wrap r @= WrapRef r
unwrap (WrapRef r) @= r
whenDiv t t1 @= if t then t1 else fix (\x. x)

impl (LIORefTCB S r) ((lcurr,mI,mS)) @= wrap (LIORefTCB I (labelOf mS(r)) r)

impl (newRef S) c @= \ l t . do
  lcurr  <- getLabel
  v      <- label l t
  r      <- newRef I lcurr v
  return (wrap r)


impl (readRef S) c @= \r . readRef I (unwrap r) >>= unlabel


impl (writeRef S) c @= \r t . let  r'  = unwrap r
                                   l   = labelOf r' in do
  lcurr <- getLabel
  toLabeled (l lub lcurr) $ do
     v   <- readRef I r'
     whenDiv (lcurr canFlowTo l lub (labelOf v)) $ do
       v'  <- label (labelOf v) t
       writeRef I r' v'


impl (labelOfR S) c @= \r . readRef I (unwrap r) >>= return . labelOf

impl (upgradeR) c @= \r l . let  r'  = unwrap r
                                 l'  = labelOf r' in do
  lcurr <- getLabel
  whenDiv (lcurr canFlowTo l') $ toLabeled l' $ do
     v   <- readRef I r'
     v'  <- upgrade v l
     writeRef I r' v'

impl (withRefs v t) ((lcurr,mI,mS)) @= impl t ((lcurr, mI, mS'))
   where
    mS'  = {a mapsto mS(a) inlinesep a element dom mS and (addrs v) }

\end{code}
\caption{Implementation mapping for flow-sensitive references. For all other terms, the function is applied homomorphically.\label{fig:fs-exts-semantics-impl}}
\end{figure}

We extend this definition naturally to convert \liofs{} environments
into \lio{} environments, by having |impl1 ((lcurr, mI, mS)) @=
(lcurr, mI')| where |mI' = mI[ a1 mapsto v1, ..., a_n mapsto v_n ]|
for each binding of the form |a_i mapsto LabeledTCB li v_i| in
|mS|. Note that the domains of |mI| and |mS| are disjoint because the
|fresh| predicate that we use in the semantics is assumed to produce
globally unique names.

In order to prove that our implementation is correct with respect to
the semantics, we show that, if we take a program with flow-sensitive
operations, and expand those operations, replacing them by the code in
Figure~\ref{fig:fs-exts-semantics-impl}, then its behavior corresponds
with the flow-sensitive semantics.

% For the proof, we will require a lemma stating that, for every
% flow-sensitive reference, the label-on-the-label always flows to the
% label of the reference at every program point.

% \begin{lemma} Let |t| be a term in \liofs{}, |c = (lcurr, mI, mS)| an
%   initial environment and |r| a flow-sensitive reference in |c|.
%   Then, for every configuration |conf ((lcurr',mI',mS')) t'| reachable
%   from |conf c t|, if we consider |mS'(r) = LabeledTCB l_o (LabeledTCB
%   l_d v)|, we have that |l_o canFlowTo l_d|.
% \end{lemma}

% We can now state our equivalence theorem.

\begin{theorem}\label{thm:eq} Let |t : LIO tau| be a well-typed term in \liofs{}.
  Then if |conf c t ==> conf c' v|, we have |conf (impl1 c) (impl t c)
  ==> conf (impl1 c') (impl v c)|, and if 
  |conf c t ==> conf c' diverge|, then
  |conf (impl1 c) (impl t c) ==> conf (impl1 c') diverge|.
  % \textrm{\hl{this is not right:
  %     the constructors for FS references are different (one wraps FI
  %     references, the other doesn't), so syntactic equiality is not
  %     right.  we need the equivalence relation I defined before}}
\end{theorem}

\subsection{Security guarantees for \liofs{}, \lioafs{} and \lioconc{}}

From previous results, we know that LIO has termination-insensitive
non-interference (TINI) in the sequential setting, and termination-sensitive
non-interference (TSNI) in the presence of concurrency. By combining the previous
embedding theorem with these results, we can show that they hold for LIO with
flow-sensitive references.

In order to make this paper self-contained, we now present our
non-interference theorems, as straightforward applications of the theorems in
previous work. Our security results rely on the notion of
|l|-equivalence for terms and configurations, which captures the idea
of terms that cannot be distinguished by an attacker which can observe
data at level |l|. A pair of terms |t1, t2| is said to be
|l|-equivalent (written |t1 &~ t2|) if, after erasing all the
information more sensitive than |l| from |t1| and |t2|, we obtain
syntactically equivalent terms. This definition extends naturally to
configurations.

Intuitively, non-interference means that an attacker at level |l|
cannot distinguish among different runs of a program with
|l|-equivalent initial configurations.

\begin{theorem}[TINI for \liofs{}]
  Consider two well-typed terms |t1 : LIO tau| and |t2 : LIO tau| in
  \liofs{} which do not contain any TCB syntax nodes, such that |t1 &~
  t2|. We assume there is an attacker that observes data at level
  |l|. Let |c| be an initial environment, and let
\[
    |conf c (t1) ==> conf c1 v1|\mbox{ and }
    |conf c (t2) ==> conf c2 v2|
\]
  Then, we have that |conf c1 v1 &~ conf c2 v2|.
\end{theorem}

\begin{proofsketch}
  By expanding all the flow-sensitive operations in |t1| and |t2| using their
  definition given in Figure~\ref{fig:fs-exts-semantics-impl}, we get
  terms in \lio{}, which by Theorem~\ref{thm:eq} has equivalent
  semantics. Therefore, the result follows from the
  termination-insensitive non-interference of \lio{}~\citep{stefan:lio}.
\end{proofsketch}

\begin{corollary}[TINI for \lioafs{}]
  The previous non-interference result can be extended to \lioafs{} in
  a straightforward manner. In \lioafs{}, the |unlabel| operation
  triggers the automatic upgrades mechanism, which consists in
  performing the |upgrade| operation for every flow-sensitive
  reference in scope before actually raising the current label.
  Regardless of how |unlabel| is used, we note that the resulting term
  (after inserting the necessary |upgrade|s), is just an \liofs{}
  term. Therefore, the main TINI result for \liofs{} applies.

 % Additionally, the |withRefs| primitive allows the programmer
 %  to restrict the set of references in scope, reducing the number of
 %  |upgrade|s that need to be performed when |unlabel| occurs.

% \hl{move
%    withRefs}
\end{corollary}

In the concurrent setting, we need to prove a lemma about the
relationship between the current label and the label on the label of
flow-sensitive references. We show that, in every context where a
reference |r| is bound, it must be the case that the current label is
at least as sensitive as the label on the label of |r|.

\begin{lemma} \label{lem:lolFlowslCurr}
  Let |t| be a well-typed term in \lioconc{}, |c = (lcurr, mI, mS)| an initial
  environment and |r| a flow-sensitive reference in |c|, where |mS(r)
  = LabeledTCB l_o (LabeledTCB l_d v)|. Then, if |conf c t ==> conf
  ((lcurr',mI',mS')) t'|, we have that |l_o canFlowTo lcurr'|.
\end{lemma}

\begin{proofsketch} Let us consider a flow-sensitive reference |r|.
  We note that the result holds immediately after creating |r|, since
  the current label becomes the label on the label of |r|, i.e. |l_o =
  lcurr|. It is easy to show that |l_o| is immutable, since there are
  no reduction rules that modify it. Moreover, given that the current
  label is monotonic, the only way in which |l_o canFlowTo lcurr| can
  cease to hold is if |r| is accessed from a different thread. But in
  order to pass |r| to a different thread, a labeled object must be
  used as intermediary, and the label of such object would have to be
  at least |lcurr|, the current label in the thread that created
  |r|. As a result, if we were to pass |r| to another thread in this
  way, then the target thread would also have to be tainted by
  |lcurr|, and the result would still hold.
\end{proofsketch}

We can now prove our non-interference theorem. This result is slightly
stronger than TINI, since it implies that there can be no termination
or internal timing leaks.

\begin{theorem}[TSNI for \lioconc{}]
  Consider two well-typed terms |t1 : LIO tau| and |t2 : LIO tau| in
  \lioconc{} which do not contain any TCB syntax nodes, such that |t1
  &~ t2|. We assume there is an attacker that observes data at level
  |l|. Let |c| be an initial environment, and let |conf c1 t1 ==> conf
  c1' t1'|.  Then, there exist |c2'| and |t2'| such that |conf c2 t2
  ==> conf c2' t2'| and |t1' &~ t2'|.
\end{theorem}

\begin{proofsketch} Because of Lemma~\ref{lem:lolFlowslCurr}, and
  looking at the embedding of |writeRef S| and |upgradeR|, we note
  that the first |readRef I| operation in each |toLabeled| block will
  be trying to raise the current label to |l|. However, since |l
  canFlowTo lcurr|, these operations will never effectively raise the
  current label. This means that using |toLabeled| is not necessary to
  preserve the semantics, because there is no need to restore the
  current label afterwards. As a result, and after removing
  |toLabeled| in these two cases, we note that the embedding produces
  valid concurrent \lio{} terms (without |toLabeled|).

  We also remark that our embedding includes no synchronization to
  ensure atomicity of the flow-sensitive operations, so certain
  interleavings that break semantic equivalence are possible. However,
  we note that all the critical sections in our operations consist in
  a |readRef I| followed by a |writeRef I|. Therefore, we argue that
  the problem could be addressed by replacing these operations with
  |atomicModifyRef I|, an atomic operation that is part of the actual
  implementation of LIO, but which we elide in order to simplify our
  presentation.

  So by expanding all the flow-sensitive operations in |t1| and |t2|
  using their definition given in
  Figure~\ref{fig:fs-exts-semantics-impl}, we get terms in concurrent
  \lio{}.  Therefore, the result follows from the
  termination-sensitive non-interference of concurrent
  \lio{}~\citep{stefan:addressing-covert}.
\end{proofsketch}

The detailed proofs for the results in this section can be found in
the extended version of the paper, at
\url{http://www.cse.chalmers.se/~buiras/fslio.html}.

% \hl{NOTE}

% Why is |toLabeled| secure in the implementation of |writeRef S|? It
% would seem that it is impossible for the first |readRef I| to
% effectively raise the current label, i.e. if a reference with LOL |l|
% is in scope, it is always the case that |l canFlowTo lcurr|. Why? If a
% reference has LOL |l|, it must have been created in a context where
% the current label was |l|. From here, it is not possible to access the
% reference from a context with a lower current label. This would
% suggest that |toLabeled| is not necessary, since |readRef| is not
% changing the current label anyway.
