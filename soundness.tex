\section{Soundness}
\label{sec:soundness}

We can implement our flow-sensitive semantics in terms of
flow-insensitive references. More concretely, every flow-sensitive
reference stored as |LabeledTCB l_o (LabeledTCB l_d v)|, can be
represented by a flow-insensitive reference with label |l_o|, whose
contents are the labeled value |LabeledTCB l_d
v|. Figure~\ref{fig:fs-extra-semantics-impl} shows the implementation
of the flow-sensitive reference operations in this setting.

\begin{figure}
\small
\begin{code}
wrap r @= LIORefTCB S r
unwrap (LIORefTCB S r) @= r
whenDiv t t1 @= if t then t1 else fix (\x. x)

newRef S l t @= do
  lcurr  <- getLabel
  v      <- label l t
  r      <- newRef I lcurr v
  return (wrap r)


readRef S r @= readRef I (unwrap r) >>= unlabel


writeRef S r t @= let  r'  = unwrap r
                       l   = labelOf r' in do
  lcurr <- getLabel
  toLabeled l $ do
     v   <- readRef I r'
     whenDiv (lcurr canFlowTo l lub (labelOf v)) $ do
       v'  <- label (labelOf v) t
       writeRef I r' v'


labelOfR S r @= readRef I (unwrap r) >>= return . labelOf

upgradeR r l @= let  r'  = unwrap r
                     l'  = labelOf r' in do
  lcurr <- getLabel
  whenDiv (lcurr canFlowTo l') $ toLabeled l' $ do
     v   <- readRef I r'
     v'  <- upgrade v l
     writeRef I r' v'

\end{code}
\caption{Implementation for flow-sensitive references.\label{fig:fs-exts-semantics-impl}}
\end{figure}

In order to prove that our implementation is correct with respect to
the semantics, we show that, if we take a program with flow-sensitive
operations, and expand those operations, replacing them by the code in
Figure~\ref{fig:fs-exts-semantics-impl}, then its behavior corresponds
with the flow-sensitive semantics.

\begin{theorem}\label{thm:eq} Let |t| in \liofs{}, and let |t'| in \lio{} be
  obtained by expanding all the flow-sensitive operations in |t| for
  their definitions in the implementation. Then, |conf c t ==> conf
  c' v| implies |conf c t' ==> conf c' v|, and if |conf c t diverge|,
  then |conf c t' diverge|.
  \textrm{\hl{this is not right: the constructors for FS references are
  different (one wraps FI references, the other doesn't), so syntactic
  equiality is not right.  we need the equivalence relation I defined before}}
\end{theorem}

For the proof we need the following lemma:

\begin{lemma} For every flow-sensitive reference $r$ with label $l_d$
  and label-on-the-label $l_o$, it holds at every program point that
  $l_o\flows l_d$, i.e. the label-onf-the-label always flows to the
  label of the reference.
\end{lemma}

From previous results, we know that |LIO| has termination-insensitive
non-interference in the sequential setting, and termination-sensitive
non-interference in the concurrent setting. By combining the previous
theorem with these results, we can show that they hold for |LIO| with
flow-sensitive references.

\begin{theorem}[Termination-insensitive non-interference for \liofs{}]
Given a program |t| in \liofs{}, an attacker that observes data at
  level $L$, and a pair of inputs $e_1$ and $e_2$ 
  indistinguishable to the attacker, then for every reduction
  sequence starting from |t e_1| there is a corresponding reduction
  sequence starting from |t e_2| such that both sequences reach 
  indistinguishable configurations.
\textrm{\hl{We proved step-by-step non-interference for lio; this is more
powerful [big step is weak, we don't need to do any application]}}
\end{theorem}

\begin{proofsketch}
  By expanding all the flow-sensitive operations in |t| using their
  definition given in Figure~\ref{fig:fs-exts-semantics-impl}, we get
  a term in \lio{}, which by Theorem~\ref{thm:eq} has equivalent
  semantics. Therefore, the result follows from the
  termination-insensitive non-interference of \lio{}.
\end{proofsketch}

\begin{theorem}[Termination-sensitive non-interference for \lioconc{}]
  Given a program |t| in \lioconc{}, and an attacker that observes data at
  level $L$, then for all inputs |e_1| and |e_2| that are
  indistinguishable to the attacker, we have that if |conf c1 (t e_1)
  --> conf c1' t_1|, then there exist |c2'| and |t_2| such that
  |conf c2 (t e_2) --> conf c2' t_2| and |t_1| and |t_2| are
  indistinguishable to the attacker.
\end{theorem}

\begin{proofsketch}
  \hl{Similar?}
\end{proofsketch}
