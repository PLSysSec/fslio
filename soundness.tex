\section{Formal results}
\label{sec:soundness}

In this section, we show that our flow-sensitive enforcement can be
embedded into the flow-insensitive version of LIO. Additionally, we
provide security guarantees in terms of non-interference by reusing
previous results about LIO.

\subsection{Embedding into \lio{}}

We will now show that we can implement our flow-sensitive semantics in
terms of flow-insensitive references. More concretely, every
flow-sensitive reference stored as |LabeledTCB l_o (LabeledTCB l_d
v)|, can be represented by a flow-insensitive reference with label
|l_o|, whose contents are the labeled value |LabeledTCB l_d v|.

Figure~\ref{fig:fs-exts-semantics-impl} shows our implementation of
the flow-sensitive reference operations in this setting.  For a given
store |c|, we define the |impl (-) (c)| function, which given a term
|t| in \liofs{}, produces a term |impl (t) (c)| in \lio{}, which is
obtained by expanding the definitions of flow-sensitive operations in
terms of flow-insensitive ones. This function is applied
homomorphically in all other cases. We use the tag |WrapRef| to mark
the flow-insensitive references that are being used to represent
flow-sensitive ones, so as to distinguish them from ordinary
flow-insensitive references. The functions |wrap| and |unwrap| are
used to add and remove this tag. For the sake of brevity, we do not
explain this mapping in detail, but we remark that it is directly
based on the rules in Figure~\ref{fig:sos:fs}.

\begin{figure}
\small
\begin{code}
wrap r @= WrapRef r
unwrap (WrapRef r) @= r
whenDiv t t1 @= if t then t1 else fix (\x. x)

impl (LIORefTCB S r) ((lcurr,mI,mS)) @= wrap (LIORefTCB I (labelOf mS(r)) r)

impl (newRef S) c @= \ l t . do
  lcurr  <- getLabel
  v      <- label l t
  r      <- newRef I lcurr v
  return (wrap r)


impl (readRef S) c @= \r . readRef I (unwrap r) >>= unlabel


impl (writeRef S) c @= \r t . let  r'  = unwrap r
                                   l   = labelOf r' in do
  lcurr <- getLabel
  toLabeled (l lub lcurr) $ do
     v   <- readRef I r'
     whenDiv (lcurr canFlowTo l lub (labelOf v)) $ do
       v'  <- label (labelOf v) t
       writeRef I r' v'


impl (labelOfR S) c @= \r . readRef I (unwrap r) >>= return . labelOf

impl (upgradeR) c @= \r l . let  r'  = unwrap r
                                 l'  = labelOf r' in do
  lcurr <- getLabel
  whenDiv (lcurr canFlowTo l') $ toLabeled l' $ do
     v   <- readRef I r'
     v'  <- upgrade v l
     writeRef I r' v'

\end{code}
\caption{Implementation mapping for flow-sensitive references. For all other terms, the function is applied homomorphically.\label{fig:fs-exts-semantics-impl}}
\end{figure}

We extend this definition naturally to convert \liofs{} environments
into \lio{} environments, by having |impl1 ((lcurr, mI, mS)) @=
(lcurr, mI')| where |mI' = mI[ a1 mapsto v1, ..., a_n mapsto v_n ]|
for each binding of the form |a_i mapsto LabeledTCB li v_i| in
|mS|. Note that the domains of |mI| and |mS| are disjoint because the
|fresh| predicate that we use in the semantics is assumed to produce
globally unique names.

In order to prove that our implementation is correct with respect to
the semantics, we show that, if we take a program with flow-sensitive
operations, and expand those operations, replacing them by the code in
Figure~\ref{fig:fs-exts-semantics-impl}, then its behavior corresponds
with the flow-sensitive semantics.

% For the proof, we will require a lemma stating that, for every
% flow-sensitive reference, the label-on-the-label always flows to the
% label of the reference at every program point.

% \begin{lemma} Let |t| be a term in \liofs{}, |c = (lcurr, mI, mS)| an
%   initial environment and |r| a flow-sensitive reference in |c|.
%   Then, for every configuration |conf ((lcurr',mI',mS')) t'| reachable
%   from |conf c t|, if we consider |mS'(r) = LabeledTCB l_o (LabeledTCB
%   l_d v)|, we have that |l_o canFlowTo l_d|.
% \end{lemma}

% We can now state our equivalence theorem.

\begin{theorem}\label{thm:eq} Let |t| in \liofs{}.
  Then if |conf c t ==> conf c' v|, we have |conf (impl1 c) (impl t c)
  ==> conf (impl1 c') (impl v c)|, and if 
  |conf c t ==> conf c' diverge|, then
  |conf (impl1 c) (impl t c) ==> conf (impl1 c') diverge|.
  % \textrm{\hl{this is not right:
  %     the constructors for FS references are different (one wraps FI
  %     references, the other doesn't), so syntactic equiality is not
  %     right.  we need the equivalence relation I defined before}}
\end{theorem}

\subsection{Security guarantees for \liofs{}, \lioafs{} and \lioconc{}}

From previous results, we know that LIO has termination-insensitive
non-interference (TINI) in the sequential setting, and termination-sensitive
non-interference (TSNI) in the presence of concurrency. By combining the previous
embedding theorem with these results, we can show that they hold for LIO with
flow-sensitive references.

In order to make this paper self-contained, we now present our
non-interference theorems, as straightforward applications of the theorems in
previous work. Our security results rely on the notion of
|l|-equivalence for terms and configurations, which captures the idea
of terms that cannot be distinguished by an attacker which can observe
data at level |l|. A pair of terms |t1, t2| is said to be
|l|-equivalent (written |t1 &~ t2|) if, after erasing all the
information more sensitive than |l| from |t1| and |t2|, we obtain
syntactically equivalent terms. This definition extends naturally to
configurations.

Intuitively, non-interference means that an attacker at level |l|
cannot distinguish among different runs of a program with
|l|-equivalent initial configurations.

\begin{theorem}[TINI for \liofs{}]
  Consider two well-typed terms |t1| and |t2| in \liofs{} which do not
  contain any TCB syntax nodes, such that |t1 &~ t2|. We assume there
  is an attacker that observes data at level |l|. Let |c| be an
  initial environment, and let
\[
    |conf c (t1) ==> conf c1 v1|\mbox{ and }
    |conf c (t2) ==> conf c2 v2|
\]
  Then, we have that |conf c1 v1 &~ conf c2 v2|.
\end{theorem}

\begin{proofsketch}
  By expanding all the flow-sensitive operations in |t| using their
  definition given in Figure~\ref{fig:fs-exts-semantics-impl}, we get
  a term in \lio{}, which by Theorem~\ref{thm:eq} has equivalent
  semantics. Therefore, the result follows from the
  termination-insensitive non-interference of \lio{}~\citep{stefan:lio}.
\end{proofsketch}

\begin{corollary}[TINI for \lioafs{}]
  The previous non-interference result can be extended to \lioafs{} in
  a straightforward manner. In \lioafs{}, the |unlabel| operation
  triggers the automatic upgrades mechanism, which consists in
  performing the |upgrade| operation for every flow-sensitive
  reference in scope before actually raising the current
  label. Additionally, the |withRefs| primitive allows the programmer
  to restrict the set of references in scope, reducing the number of
  |upgrade|s that need to be performed when |unlabel| occurs.
  Regardless of how |unlabel| and |withRefs| are used, we note that
  the resulting term (after inserting the necessary |upgrade|s), is just an
  \liofs{} term. Therefore, the main TINI result for \liofs{} applies.
\end{corollary}

In the concurrent setting, we have a stronger result, where the
termination and internal timing covert channels are closed.

\begin{theorem}[TSNI for \lioconc{}]
  Consider two well-typed terms |t1| and |t2| in \lioconc{} which do not
  contain any TCB syntax nodes, such that |t1 &~ t2|. We assume there
  is an attacker that observes data at level |l|. Let |c| be an
  initial environment, and let |conf c1 t1 ==> conf c1' t1'|.
  Then, there exist |c2'| and |t2'| such that |conf c2 t2 ==> conf
  c2' t2'| and |t1' &~ t2'|.
\end{theorem}

\begin{proofsketch} \hl{Revise} By expanding all the flow-sensitive
  operations in |t| using their definition given in
  Figure~\ref{fig:fs-exts-semantics-impl}, we get a term in concurrent
  \lio{}.  \hl{Show that toLabeled is fine.}
  Therefore, the result follows from the termination-sensitive
  non-interference of concurrent \lio{}~\citep{stefan:addressing-covert}.
\end{proofsketch}

\hl{include link to extended version}

% \hl{NOTE}

% Why is |toLabeled| secure in the implementation of |writeRef S|? It
% would seem that it is impossible for the first |readRef I| to
% effectively raise the current label, i.e. if a reference with LOL |l|
% is in scope, it is always the case that |l canFlowTo lcurr|. Why? If a
% reference has LOL |l|, it must have been created in a context where
% the current label was |l|. From here, it is not possible to access the
% reference from a context with a lower current label. This would
% suggest that |toLabeled| is not necessary, since |readRef| is not
% changing the current label anyway.
