\section{Soundness}
\label{sec:soundness}

In this section, we provide security guarantees for our approach. In
order to prove non-interference, we will show that we can implement
our flow-sensitive semantics in terms of flow-insensitive
references. More concretely, every flow-sensitive reference stored as
|LabeledTCB l_o (LabeledTCB l_d v)|, can be represented by a
flow-insensitive reference with label |l_o|, whose contents are the
labeled value |LabeledTCB l_d v|.

Figure~\ref{fig:fs-exts-semantics-impl} shows the implementation of
the flow-sensitive reference operations in this setting.  For a given
store |c|, we define the |impl (-) (c)| function, which given a term |t|
in \liofs{}, produces a term |impl (t) (c)| in \lio{}, which is obtained
by expanding the definitions of the flow-sensitive operations. The
function is applied homomorphically in all other cases.

\begin{figure}
\small
\begin{code}
wrap r @= LIORefTCB S r
unwrap (LIORefTCB S r) @= r
whenDiv t t1 @= if t then t1 else fix (\x. x)

impl (LIORefTCB S r) ((lcurr,mI,mS)) @= wrap (LIORefTCB I (labelOf mS(r)) r)

impl (newRef S) c @= \ l t -> do
  lcurr  <- getLabel
  v      <- label l t
  r      <- newRef I lcurr v
  return (wrap r)


impl (readRef S) c @= \r -> readRef I (unwrap r) >>= unlabel


impl (writeRef S) c @= \r t -> let  r'  = unwrap r
                                    l   = labelOf r' in do
  lcurr <- getLabel
  toLabeled l $ do
     v   <- readRef I r'
     whenDiv (lcurr canFlowTo l lub (labelOf v)) $ do
       v'  <- label (labelOf v) t
       writeRef I r' v'


impl (labelOfR S) c @= \r -> readRef I (unwrap r) >>= return . labelOf

impl (upgradeR) c @= \r l -> let  r'  = unwrap r
                                  l'  = labelOf r' in do
  lcurr <- getLabel
  whenDiv (lcurr canFlowTo l') $ toLabeled l' $ do
     v   <- readRef I r'
     v'  <- upgrade v l
     writeRef I r' v'

\end{code}
\caption{Implementation mapping for flow-sensitive references. For all other terms, the function is applied homomorphically.\label{fig:fs-exts-semantics-impl}}
\end{figure}

We extend this definition naturally to convert \liofs{} stores into
\lio{} stores, by having |impl1 ((lcurr, mI, mS)) @= (lcurr, mI')|
where |mI' = mI[ a1 mapsto v1, ..., a_n mapsto v_n ]| for each binding
of the form |a_i mapsto LabeledTCB l v_i| in |mS|.

In order to prove that our implementation is correct with respect to
the semantics, we show that, if we take a program with flow-sensitive
operations, and expand those operations, replacing them by the code in
Figure~\ref{fig:fs-exts-semantics-impl}, then its behavior corresponds
with the flow-sensitive semantics.



\begin{theorem}\label{thm:eq} Let |t| in \liofs{}, and let |t' = impl t| in \lio{},
  and suppose that |conf (lcurr,mI,mS) t ==> conf (lcurr',mI',mS') v|.
  Let |c2 = (lcurr,mI merge mS)|, then

  |conf c2 t' ==> conf c2' v'|, and if |conf c t diverge|, then
  |conf c2 t' diverge|.
 \textrm{\hl{this is not right: the
      constructors for FS references are different (one wraps FI
      references, the other doesn't), so syntactic equiality is not
      right.  we need the equivalence relation I defined before}}
\end{theorem}

For the proof we need the following lemma:

\begin{lemma} For every flow-sensitive reference $r$ with label $l_d$
  and label-on-the-label $l_o$, it holds at every program point that
  $l_o\flows l_d$, i.e. the label-onf-the-label always flows to the
  label of the reference.
\end{lemma}

From previous results, we know that LIO has termination-insensitive
non-interference in the sequential setting, and termination-sensitive
non-interference in the concurrent setting. By combining the previous
theorem with these results, we can show that they hold for LIO with
flow-sensitive references.

\begin{theorem}[Termination-insensitive non-interference for \liofs{}]
Given a program |t| in \liofs{}, an attacker that observes data at
  level $L$, and a pair of inputs $e_1$ and $e_2$ 
  indistinguishable to the attacker, then for every reduction
  sequence starting from |t e_1| there is a corresponding reduction
  sequence starting from |t e_2| such that both sequences reach 
  indistinguishable configurations.
\textrm{\hl{We proved step-by-step non-interference for lio; this is more
powerful [big step is weak, we don't need to do any application]}}
\end{theorem}

\begin{proofsketch}
  By expanding all the flow-sensitive operations in |t| using their
  definition given in Figure~\ref{fig:fs-exts-semantics-impl}, we get
  a term in \lio{}, which by Theorem~\ref{thm:eq} has equivalent
  semantics. Therefore, the result follows from the
  termination-insensitive non-interference of \lio{}.
\end{proofsketch}

\begin{theorem}[Termination-sensitive non-interference for \lioconc{}]
  Given a program |t| in \lioconc{}, and an attacker that observes data at
  level $L$, then for all inputs |e_1| and |e_2| that are
  indistinguishable to the attacker, we have that if |conf c1 (t e_1)
  --> conf c1' t_1|, then there exist |c2'| and |t_2| such that
  |conf c2 (t e_2) --> conf c2' t_2| and |t_1| and |t_2| are
  indistinguishable to the attacker.
\end{theorem}

\begin{proofsketch}
  \hl{Similar?}
\end{proofsketch}
