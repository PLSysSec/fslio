\section{Soundness}
\label{sec:soundness}

In this section, we provide security guarantees for our approach. In
order to prove non-interference, we will show that we can implement
our flow-sensitive semantics in terms of flow-insensitive
references. More concretely, every flow-sensitive reference stored as
|LabeledTCB l_o (LabeledTCB l_d v)|, can be represented by a
flow-insensitive reference with label |l_o|, whose contents are the
labeled value |LabeledTCB l_d v|.

Figure~\ref{fig:fs-exts-semantics-impl} shows our implementation of
the flow-sensitive reference operations in this setting.  For a given
store |c|, we define the |impl (-) (c)| function, which given a term |t|
in \liofs{}, produces a term |impl (t) (c)| in \lio{}, which is obtained
by expanding the definitions of the flow-sensitive operations. The
function is applied homomorphically in all other cases.

\begin{figure}
\small
\begin{code}
wrap r @= WrapRef r
unwrap (WrapRef r) @= r
whenDiv t t1 @= if t then t1 else fix (\x. x)

impl (LIORefTCB S r) ((lcurr,mI,mS)) @= wrap (LIORefTCB I (labelOf mS(r)) r)

impl (newRef S) c @= \ l t -> do
  lcurr  <- getLabel
  v      <- label l t
  r      <- newRef I lcurr v
  return (wrap r)


impl (readRef S) c @= \r -> readRef I (unwrap r) >>= unlabel


impl (writeRef S) c @= \r t -> let  r'  = unwrap r
                                    l   = labelOf r' in do
  lcurr <- getLabel
  toLabeled l $ do
     v   <- readRef I r'
     whenDiv (lcurr canFlowTo l lub (labelOf v)) $ do
       v'  <- label (labelOf v) t
       writeRef I r' v'


impl (labelOfR S) c @= \r -> readRef I (unwrap r) >>= return . labelOf

impl (upgradeR) c @= \r l -> let  r'  = unwrap r
                                  l'  = labelOf r' in do
  lcurr <- getLabel
  whenDiv (lcurr canFlowTo l') $ toLabeled l' $ do
     v   <- readRef I r'
     v'  <- upgrade v l
     writeRef I r' v'

\end{code}
\caption{Implementation mapping for flow-sensitive references. For all other terms, the function is applied homomorphically.\label{fig:fs-exts-semantics-impl}}
\end{figure}

We extend this definition naturally to convert \liofs{} environments into
\lio{} environments, by having |impl1 ((lcurr, mI, mS)) @= (lcurr, mI')|
where |mI' = mI[ a1 mapsto v1, ..., a_n mapsto v_n ]| for each binding
of the form |a_i mapsto LabeledTCB l v_i| in |mS|.

In order to prove that our implementation is correct with respect to
the semantics, we show that, if we take a program with flow-sensitive
operations, and expand those operations, replacing them by the code in
Figure~\ref{fig:fs-exts-semantics-impl}, then its behavior corresponds
with the flow-sensitive semantics.

For the proof, we will require a lemma stating that, for every
flow-sensitive reference, the label-on-the-label always flows to the
label of the reference at every program point.

\begin{lemma} Let |t| be a term in \liofs{}, |c = (lcurr, mI, mS)| an
  initial environment and |r| a flow-sensitive reference in |c|.
  Then, for every configuration |conf ((lcurr',mI',mS')) t'| reachable
  from |conf c t|, if we consider |mS'(r) = LabeledTCB l_o (LabeledTCB
  l_d v)|, we have that |l_o canFlowTo l_d|.
\end{lemma}

We can now state our equivalence theorem.

\begin{theorem}\label{thm:eq} Let |t| in \liofs{}.
  Then if |conf c t ==> conf c' v|, we have |conf (impl1 c) (impl t c)
  ==> conf (impl1 c') (impl v c)|, and if |conf c t diverge|, then
  |conf (impl1 c) (impl t c) diverge|.
  % \textrm{\hl{this is not right:
  %     the constructors for FS references are different (one wraps FI
  %     references, the other doesn't), so syntactic equiality is not
  %     right.  we need the equivalence relation I defined before}}
\end{theorem}

From previous results, we know that LIO has termination-insensitive
non-interference in the sequential setting, and termination-sensitive
non-interference in the concurrent setting. By combining the previous
theorem with these results, we can show that they hold for LIO with
flow-sensitive references.

Our security results rely on the notion of |l|-equivalence for terms
and configurations, which captures the idea of terms that cannot be
distinguished by an attacker which can observe data at level |l|. A
pair of terms |t1, t2| is said to be |l|-equivalent (written |t1 &~
t2|) if, after erasing all the information more sensitive than |l|
from |t1| and |t2|, we obtain syntactically equivalent terms. This
definition extends naturally to configurations.

Intuitively, non-interference means that an attacker at level |l|
cannot distinguish among different runs of a program with
|l|-equivalent initial configurations.

\begin{theorem}[Termination-insensitive non-interference for \liofs{}]
  Consider a program |t| in \liofs{}, an attacker that observes data at
  level |l|, and a pair of inputs |e_1| and |e_2| such that |e_1 &~
  e_2|. Let |c| be an initial environment, and let
\[
    |conf c (t e_1) ==> conf c1 v1|\mbox{ and }
    |conf c (t e_2) ==> conf c2 v2|
\]
  Then, we have that |conf c1 v1 &~ conf c2 v2|.
\end{theorem}

\begin{proofsketch}
  By expanding all the flow-sensitive operations in |t| using their
  definition given in Figure~\ref{fig:fs-exts-semantics-impl}, we get
  a term in \lio{}, which by Theorem~\ref{thm:eq} has equivalent
  semantics. Therefore, the result follows from the
  termination-insensitive non-interference of \lio{}.
\end{proofsketch}

In the concurrent setting, we have a stronger result, where the
termination and internal timing covert channels are closed.

\begin{theorem}[Termination-sensitive non-interference for \lioconc{}]
  Given a program |t| in \lioconc{}, and an attacker that observes
  data at level |l|, then for all inputs |e_1| and |e_2| such that
  |e_1 &~ e_2|, we have that if |conf c1 (t e_1) --> conf c1' t_1|,
  then there exist |c2'| and |t_2| such that |conf c2 (t e_2) --> conf
  c2' t_2| and |t_1 &~ t_2|.
\end{theorem}

\begin{proofsketch} \hl{Revise} By expanding all the flow-sensitive
  operations in |t| using their definition given in
  Figure~\ref{fig:fs-exts-semantics-impl}, we get a term in concurrent
  \lio{}.  \hl{Show that toLabeled is fine.}
  Therefore, the result follows from the termination-sensitive
  non-interference of \lio{}.
\end{proofsketch}

\hl{NOTE}

Why is |toLabeled| secure in the implementation of |writeRef S|? It
would seem that it is impossible for the first |readRef I| to
effectively raise the current label, i.e. if a reference with LOL |l|
is in scope, it is always the case that |l canFlowTo lcurr|. Why? If a
reference has LOL |l|, it must have been created in a context where
the current label was |l|. From here, it is not possible to access the
reference from a context with a lower current label. This would
suggest that |toLabeled| is not necessary, since |readRef| is not
changing the current label anyway.
