\section{Introduction to LIO}
\label{sec:background}

\concept{LIO library as LIO-monad}
LIO is a language-level IFC system, implemented as a Haskell
library.
%
Concretely, LIO provides programmers with a new monad, called |LIO|,
that is similar to---and is intended to be used in place of---the
standard Haskell |IO| monad, but additionally monitors and controls
the flow of information.
%
In turn, various practical features (e.g., mutable references and
threads) are implemented as combinators in this monad.
%

\concept{Current label used to govern flows}
The |LIO| monad encapsulates the state necessary to enforce IFC for
the computation under evaluation.
%
Part of this state is the ``current label.''
%
Intuitively, the current label serves a role similar to the program
counter (|pc|) of more-traditional IFC systems
(e.g.,~\cite{FlowCaml}).
%
Namely, it restricts the current computation from performing arbitrary
side-effects.
%
For instance, if the current label is |lcurr|, LIO restricts the
computation to only reading data labeled |l_d|, where |l_d canFlowTo
lcurr|.
%
Similarly, it restricts the computation from writing to entities
labeled |l_e|, unless |lcurr canFlowTo l_e|.

\concept{Current label is label on all in scope}
To soundly reason about IFC, every object in an IFC system \emph{must}
be labeled.
%
This includes literals, terms, labels, execution contexts, etc.
%
However and in contrast to language-based systems (e.g.,
Jif~\cite{myers:jif}, FlowCaml~\cite{FlowCaml}, Breeze~\cite{Breeze},
etc.), where every value is explicitly labeled, values in LIO are
Haskell values and thus do not have explicit labels.
%
(LIO cannot explicitly label every Haskell value without modifying the
language runtime!)
%
Instead, and like several IFC operating
systems~\cite{efstathopoulos:asbestos,zeldovich:histar}, LIO takes a
coarse-grained approach and use the current label to protect all
values in scope, i.e., in LIO, the current label |lcurr| is the label
on all ``unlabeled'' values.
%
Since the current label is used to restrict the current computation
from performing arbitrary side-effects---this ensures that that the
confidentiality (and integrity) of all values in scope are preserved.
%
(Henceforth, we assume that all computations are encoded in |LIO|.)

\concept{Floating label}
Further borrowing from IFC operating systems (namely,
HiStar~\cite{zeldovich:histar}), LIO raises the current label to
protect newly read data that is incorporated in scope.
%
That is, the current label is raised to ``float'' above the labels of
all the objects read by the current computation.
(Hence the name ``floating-label.'')
% 
Raising the current label allows computations to flexibly read data,
at the cost of being more limited in where they can subsequently
write.
%
Concretely, a computation with current label |lcurr| can read data
labeled |l_d| by raising its current label to |lcurr' = lcurr lub
l_d|, but can thereafter only write to entities labeled |l_e| if
|lcurr' canFlowTo l_e|.
%
For example, LIO allows a public computation to read secret data by
raising |lcurr| from |L| to |H|. Importantly, the new current label
prevents the computation from subsequently writing to public entities.

\concept{Labeled objects}
\hl{TODO:talk about labeled values and references}
 
\subsection{\lio: A corase-grained IFC calculus}
 
\concept{\lio{} syntax}
To give precise semantics, we consider LIO as an extended
simply-typed, call-by-name $\lambda$-calculus, called \lio.
%
The formal syntax of the core \lio{} calculus, parametric in the label
type |lattice|, is given in Fig.~\ref{fig:language:base}.
%
Syntactic categories |v|, |t|, and |tau| represent values, terms, and
types, respectively.
%
Values include standard primitives (Booleans, unit,
and $\lambda$-abstractions) and terminals corresponding to labels
(|l|) and monadic values (|LIOTCB tau|).\footnote{
We restrict our formalization to computations implemented in the |LIO|
monad and only consider Haskell features relevant to IFC, similar to
the presentation of LIO in~\tocite{jfptechreport}.
}
%
Terms are composed of standard constructs (values, variables |x|,
function application, the |fix| operator, and conditionals), terminals
corresponding to label operations (|t lop t|, where |lub| is the join,
|glb| is the meet, and |canFlowTo| is the partial-order on labels),
standard monadic operators (|return t| and |t >>= t|), and |getLabel|,
describe below.
%
Types consist of Booleans, unit, function types, labels, and |LIO|
computations; since the \lio{} type system is standard, we do not
discuss it further.

\begin{figure}
\small
\centering
%format Values  = "\mathrm{Values}"
%format Terms   = "\mathrm{Terms}"
%format Types   = "\mathrm{Types}"
%format LOps    = "\mathrm{Ops}_"lattice
\begin{code}
Values  v    ::=  true | false | () | \x.t | lattice | LIOTCB t
Terms   t    ::=  v | x | t t | fix t | if t then t else t
               |  t lop t | return t | t >>= t | getLabel
Types   tau  ::=  Bool | () | tau -> tau | lattice | LIO tau  
LOps    lop  ::=  lub | glb | canFlowTo
\end{code}
\caption{Base \lio{} syntactic categories.
\label{fig:language:base}}
\end{figure}

\concept{eval ctx}
We use operational semantics with evaluation contexts in the style of
Felleisen and Hieb to specify the reduction rules for \lio~\tocite{}.
%
Figure~\ref{fig:sos:base} defines the reduction rules for the base
calculus with an evaluation context for pure
terms (|Ep|) and one for monadic terms (|E|).
%
The evaluation context are standard; we solely highlight that terms
are evaluated only when used in the top-level context (|E|), as in
Haskell.

\concept{pure red}
Similarly, the reduction rules for pure terms are mostly standard.
%
Only two points are worth noting.
%
First, we define substitution |{t2 / x } t1| in the usual way:
homomorphic on all operators and renaming bound names to avoid
captures. 
%
Second, our label operations |lub|, |glb|, and |canFlowTo| rely on the
label-specific implementation of these lattice operators, as used in
the premise of rule \ruleref{labelOp};
%
we use the meta-level partial function |denot cdot|, which maps terms
to a values, to precisely capture this implementation detail.

\begin{figure}[t] % sos:base
\small
\begin{code}
Ep  ::= Ep t | fix Ep | if Ep then t else t | Ep lop t | v lop Ep
E   ::= []| Ep | E >>= t 
\end{code}

\begin{mathpar}
\inferrule[app]
{ } { |Ep[(\x.t1) t2] ~> Ep[{ t2 / x } t1]| }
\and
\inferrule[fix]
{ } { |Ep[fix (\x.t)] ~> Ep[{fix (\x.t) / x } t|] }
\and
\inferrule[ifTrue]
{ } { |Ep[if true then t2 else t3] ~> Ep[t2]| }
\and
\inferrule[ifFalse]
{ } { |Ep[if false then t2 else t3] ~> Ep[t3]| }
\and
\inferrule[labelOp]
{ | v = denot ( l1 lop l2 ) | }
{ |Ep[l1 lop l2] ~> Ep[v]| }
\and
\inferrule[return]
{ } { |conf c (E[return t]) --> conf c (E[LIOTCB t])| }
\and
\inferrule[bind]
{ }
{ |conf c (E[(LIOTCB t1) >>= t2]) --> conf c (E[t2 t1])| }
\and
\inferrule[getLabel]
{ |c = (lcurr, ...)|  }
{
|conf c (E[getLabel]) --> conf c (E[return lcurr])|
}
\end{mathpar}
\caption{Reduction rules for base \lio.\label{lio:sos:base}}
\end{figure}

\concept{monad red}
The reduction rules for monadic terms deserve some attention.
%
Rather than modeling state, such as the current label, are
purely-functional monad layers, we take an operational and
more-imperative approach by modeling state as a separate component.
%
Specifically, a top-level, i.e., computation is a \emph{configuration}
of the form |conf c t|, where |t| is the monadic term and |c| is the
state associated with the term.
%
(Under this definition, \lio{} type-judgements have the form | G, c :-
t : LIO tau|, where |G| is the usual type environment.)
%
As a result of this encoding, the definition for |return| and |(>>=)|
are trivial: the former simply reduces to a monadic value by wrapping
the term with the |LIOTCB| constructor, while the latter evaluates the
left-hand term and supplies the result to the right-hand term, as
usual.
 
Rule \ruleref{getLabel} defines our first and trivial LIO library
function |getLabel| which retrieves the current label.
%
Recall that it is this label that protects all the values in scope.
%
However, since neither |return| nor |>>=| perform any security checks,
all LIO functions must inspect the current label to enforce IFC.
%
For example, we can define a |publish| function that writes the
supplied value to a public channel in terms of a |publishTCB| function
(that unsafely writes any data to the channel) as follows:
\begin{code}
publish v = do  lcurr <- getLabel 
                when (lcurr canFlowTo low) (publishTCB v)
\end{code}
Hence, if the current computation has read any sensitive data---and
thus the current label is |high|---it cannot subsequently leak it with
publish.\footnote{
  As with other TCB functions, we assume that |publishTCB| is not part
  of the surface syntax.
}

\subsection{Labeled values}

\concept{|lcurr| is too coarse-grained}
Using |lcurr| as the label on all terms in scope makes it trivial to
reason about issues that have traditionally been hard to deal with in
IFC system.
%
For example, LIO does not have to explicitly handle the implicit flows
problem: branch conditions (which are are simply values of type
|Bool|) are labeled |lcurr|, and thus any subsequent writes cannot leak
the sensitive bit---the current label is used when governing all
writes (even those in a branch).
%
Of course, this coarse-grained labeling approach has a severe: a piece
of code cannot, for example, both write |medium| data to a channel
labeled |medium| after writing |high| data to a |high| channel---once
|high| data is read, the current label is raised to |high| thereby
``over tainting'' |medium| data.
 
\concept{labeled values}
To address this limitation, LIO provides |Labeled| values, which, like
language-based systems, can be used to associate an explicit label
with a term, irrespective of the current label.
%
Intuitively, a term can be heterogeneously labeled by a label other
than |lcurr| if we can ``transfer'' protection from the current label
to this |Labeled| value (e.g., by ensuring that the protected value
cannot be inspected in a (future) less-sensitive context).
%
To this end we extend \lio{} as shown in Figure~\ref{fig:sos:labeled}.
\begin{figure}[ht] % labeled
\small
\begin{code}
v    ::= cdots  | LabeledTCB l t
t    ::= cdots  | label t t | unlabel t | labelOf t | upgrade t t
tau  ::= cdots  | Labeled tau
Ep   ::= cdots  | label Ep t | unlabel Ep | labelOf Ep
                | upgrade Ep t | upgrade v Ep
\end{code}

\begin{mathpar}
\inferrule[label]
{ |c = (lcurr, ...)|\\
  |lcurr canFlowTo l ~> true| 
}
{
|conf c (E[label l t]) --> conf c (E[return (LabeledTCB l t)])|
}
\and

\inferrule[unlabel]
{ |c = (lcurr, ...)|\\
  |lcurr lub l ~> lcurr'|\\
  |c' = (lcurr', ...)|
}
{
|conf c (E[unlabel (LabeledTCB l t)]) --> conf c' (E[return t])|
}
\and
\inferrule[labelOf]
{ }
{ |Ep[labelOf (LabeledTCB l t)] ~> Ep[l]| }
\and
\inferrule[upgrade]
{ |c = (lcurr, ...)|\\
  |t' = lcurr lub l lub l'|}
{ |conf c (E[upgrade (LabeledTCB l t) l']) --> conf c (E[label t' t])| }
\end{mathpar}
\caption{Extending \lio{} with labeled values\label{fig:sos:labeled}.}
\end{figure}

\concept{label}
The |label| terminal is used to explicitly label a term.
%
As rule \ruleref{label} shows, the function associates the supplied
label |l| with term |t| by wrapping the term with the |LabeledTCB|
constructor.
%
Importantly, it first asserts that the new label (|l|) used to
protect |t| is at least as restricting as the old label (the current
label, |lcurr|), i.e., |lcurr canFlowTo l ~> true|.
 
\concept{unlabel}
Dually, |unlabel|, unwraps explicitly labeled values.
%
As defined in rule \ruleref{unlabel}, given a labeled value
|LabeledTCB l t| the function returns the wrapped term |t|.
%
Since the returned term is no longer explicitly labeled by |l|, and
is instead protected by the current label, |lcurr| must be at least
as restricting as |l|.
%
To ensure this, the current label is raised from |lcurr| to |lcurr lub
l|---this captures the fact that the remaining computation might
depend on |t|. 
%
Moreover, this highlights the fact that the current label always
``floats'' above the labels of the values observed by the current
computation.

\concept{labelOf}
The |labelOf| function provides a means for inspecting the label of a
labeled value.
%
As detailed by reduction rule \ruleref{labelOf}, given a labeled value
|LabeledTCB l t| the function returns the label |l| protecting term
|t|.
%
This allows code to check the label of a labeled value before deciding
to unlabel it, and thereby raise the current label.
%
It it worth noting that regardless of the current label in the
configuration, the label of a labeled value can be inspected---hence
labels are effectively ``public.''\footnote{
In fact labels are actually protected by the current label, but since
code can always observe objects labeled at the current label this is
akin to being public.
}

\concept{upgrade}
Finally, |upgrade| allows a piece of code raise the label of a
labeled value.
%
Since labeled values are immutable, this function, in effect produces
another labeled value that is protected by a label more restricting
than the current one.
%
Since LIO has the invariant that a computation can only create or
write to entities above the current label, we use |lcurr| in addition
to the supplied label when upgrading a labeled value.

\concept{label creep}
Intuitively, we can try to define |upgrade| in terms of existing
terminals by first |unlabel|ing the labeled value and then |label|ing
the result with the join of the current label, existing label and new
label.
%
Unfortunately, these semantics are different; |unlabel| raises the
current label and, while the |label| will succeed in creating a new
labeled value with the desired label, the current label cannot be
lowered to the label at the point before the |unlabel|, since we now
have (potentially) more sensitive data in scope.
%
This raising of the current label to a point where the computation can
no longer perform useful tasks is known as \emph{label
creep}~\cite{sabelfeld:language-based-iflow}.
%
Label creep does not compromise security, since the current
label still protects all data in lexical scope.
%
However, it makes LIO overly restrictive---in general, being able to
perform computations on sensitive data without raising the current
label is crucial to building practical applications.

\concept{toLabeled}
To this end, LIO provides the |toLabeled| function which executes an
|LIO| action (that may raise the current label) and subsequently
restores the current label.
%
Extending terms and the pure evaluation context with |toLabeled| (|t
::= cdots inlinesep toLabeled t t| and |Ep ::= cdots inlinesep
toLabeled Ep t|, respectively) we give the precise semantics of
|toLabeled| as follows:
%
\begin{mathpar}
\inferrule[toLabeled]
{
|c = (lcurr, ...)|\\
|lcurr canFlowTo l ~> true| \\
|conf c t ==> conf c' (LIOTCB t')| \\
|c' = (lcurr', ...)|\\
|lcurr' canFlowTo l ~> true|\\
|c'' = c merge c'|
}
{
|conf c (E[toLabeled l t]) --> conf c'' (E[label l t'])|
}
\end{mathpar}
%
Intuitively, if the current label at the point |toLabeled l t| is
executed is |lcurr|, |toLabeled| evaluates |t| to completion and
restores the current label to |lcurr|, i.e., |toLabeled| provides a
separate context in which |t| is evaluated.
%
(Here, the state merge function |merge| is defined as: |c merge c' @=
c|, in the next section we present an alternative definition.)
%
Of course, since returning the result of |t| directly would allow for
trivial leaks, |toLabeled| labels |t'| with |l|.
%
This effectively states that the result of |t| is protected by label
|l|, as opposed to the current label at the point |t| completed.
%
Importantly, this requires that the result not be more sensitive than
|l|.

\concept{upgrade with toLabeled}
Note that with |toLabeled| we can now define |upgrade| as follows:
\begin{code}
upgrade t1 t2 @= getLabel >>= \l.
  toLabeled (labelOf t1 lub l lub t2) (unlabel t1)
\end{code}
However, since |toLabeled| needs to be modified to accommodate for
flow-sensitive references with auto-upgrading, we leave our definition
|upgrade| as a given in Figure~\ref{fig:sos:labeled}.\footnote{
In section~\ref{sec:flow-sensitive}, we define an alternative version
of |toLabeled|, in terms of which we can define the upgrade function
such that its semantics are equivalent to those given
Figure~\ref{fig:sos:labeled}. This definition is:
|upgrade t1 t2 @= getLabel >>= \l.
  toLabeled' (labelOf t1 lub l lub t2) nil (unlabel t1)|
}


\subsection{Labeled references}

\hl{HERE}

\begin{figure}[!ht]
\small
\begin{code}
v    ::= cdots  | LIORefTCB I v t
t    ::= cdots  | newRef s t t | writeRef s t t | readRef s t | labelOfR s t
tau  ::= cdots  | LIORef s tau
Ep   ::= cdots  | newRef s Ep t | writeRef s Ep t | readRef s Ep | labelOfR s Ep
\end{code}

\begin{mathpar}
\inferrule[newRef-|I|]
{ |c = (lcurr, mI, ...)|\\
  |lcurr canFlowTo l ~> true|\\
  |mI' = mI[a mapsto LabeledTCB l t]|\\
  |c' = (lcurr, mI', ...)|
}
{ |conf c (E[newRef I l t]) --> conf c' (E[return (LIORefTCB I l a)])| }
{ |fresh a| }

\and

\inferrule[readRef-|I|]
{ |c = (lcurr, mI, ...)|
}
{ |conf c (E[readRef I (LIORefTCB I l a)]) --> conf c (E[unlabel mI(a)])| }


\and
\inferrule[writeRef-|I|]
{ |c = (lcurr, mI, ...)|\\
  |lcurr canFlowTo l ~> true|\\
  |mI' = mI[a mapsto LabeledTCB l t]|\\
  |c' = (lcurr, mI', ...)|
}
{ |conf c (E[writeRef I (LIORefTCB I l a) t]) --> conf c' (E[return ()])| }


\and

\inferrule[labelOf-|I|]
{ }
{ |Ep[labelOfR I (LIORefTCB I l a)]) --> Ep[l]| }
\end{mathpar}
\caption{Semantics for references, with |s  ::=  S inlinesep
I|.\label{fig:sos:ref-syntax}
\label{fig:sos:refs}.}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[h!]
\small
\begin{mathpar}
\inferrule
{ |conf c t --> conf c' t'| }
{ |conf c (E[t]) --> conf c' (E[t'])| }
\and
\inferrule
{ |Ep[t] ~> Ep[t']| }
{ |conf c (Ep[t]) --> conf c (Ep[t'])| }
\and
\inferrule
{ |t ~> t'| }
{ |Ep[t] ~> Ep[t']| }
\end{mathpar}
\caption{Evaluation relations \hl{ Maybe useful somewhere; appendix? } }
\end{figure}


\hl{
Maybe useful somewhere else:
The design constraints imposed by the library approach has led to a
novel point in the design space of language-level IFC systems---when
compared to more traditional IFC systems---that incorporates ideas
from previous IFC operating systems.
}
