\section{Brief introduction to LIO}
\label{sec:background}

LIO is a language-level IFC system, implemented as a Haskell
library.
%
Specifically, LIO provides programmers with a new monad, called |LIO|,
that is similar to---and is intended to be used in place of---the
standard Haskell |IO| monad, but additionally monitors and controls
the flow of information.
%
The LIO library provides various practical features (e.g., mutable
references and threads) as combinators in this monad.

\Red{TODO: describe LIO monad and current label}

%
Below we describe the semantics of LIO as an extended simply-typed,
call-by-name $\lambda$-calculus, called \lio, parametric in the label
type |lattice|.

The formal syntax of the core \lio{} calculus is given in
Fig.~\ref{fig:language:base}.
%
Syntactic categories |v|, |t|, and |tau| represent values, terms, and
types, respectively.
%
Values include standard primitives (Booleans, unit,
and $\lambda$-abstractions) and terminals corresponding to labels
(|lattice|) and monadic values (|LIOTCB tau|).\footnote{
We restrict our formalization to computations implemented in the |LIO|
monad and only consider Haskell features relevant to IFC, similar to
the presentation of LIO in~\tocite{jfptechreport}.
}
%
Terms constitute standard constructs (values, variables |x|, function
application, the |fix| operator, and conditionals), terminals
corresponding to label operations (|t lop t|), standard monadic
operators (|return t| and |t >>= t|), and |getLabel|, describe below.
%
Types consist of Booleans, unit, function types, labels, and |LIO|
computations; since the \lio{} type system is standard, we do not
discuss it further.

\begin{figure}
\centering
%format Values  = "\mathrm{Values}"
%format Terms   = "\mathrm{Terms}"
%format Types   = "\mathrm{Types}"
%format LOps    = "\mathrm{Ops}_"lattice
\begin{code}
Values  v    ::=  true | false | () | \x.t | lattice | LIOTCB t
Terms   t    ::=  v | x | t t | fix t | if t then t else t
               |  t lop t | return t | t >>= t | getLabel
Types   tau  ::=  Bool | () | tau -> tau | lattice | LIO tau  
LOps    lop  ::=  canFlowTo | lub | glb
\end{code}
\caption{Base \lio{} syntactic categories.
\label{fig:language:base}}
\end{figure}

An LIO program is a \emph{configuration} of the form |conf c t|, where
|t| is the monadic term under evaluation, such that |:- t : LIO tau|,
and |c| is state associated with the computation.
%
The state |c| is a tuple that contains both the current label |lcurr|
and memory store |m|, i.e., |c = (lcurr, m, ...)|.
%

\begin{figure}[ht]
\begin{mathpar}
\inferrule
{ |conf c t --> conf c' t'| }
{ |conf c (E[t]) --> conf c' (E[t'])| }
\and
\inferrule
{ |Ep[t] ~> Ep[t']| }
{ |conf c (Ep[t]) --> conf c (Ep[t'])| }
\and
\inferrule
{ |t ~> t'| }
{ |Ep[t] ~> Ep[t']| }
\end{mathpar}
\caption{Evaluation relations}
\end{figure}


\begin{figure}[t] % sos:base
\begin{mathpar}
\inferrule[app]
{ } { |Ep[(\x.t1) t2] ~> Ep[{ t2 / x } t1]| }
\and
\inferrule[fix]
{ } { |Ep[fix (\x.t)] ~> Ep[{fix (\x.t) / x } t|] }
\and
\inferrule[ifTrue]
{ } { |Ep[if true then t2 else t3] ~> Ep[t2]| }
\and
\inferrule[ifFalse]
{ } { |Ep[if false then t2 else t3] ~> Ep[t3]| }
\and
\inferrule[lOp]
{ | denot ( l3 = l1 lop l2 ) | }
{ |Ep[l1 lop l2] ~> Ep[l3]| }
\and
\inferrule[return]
{ } { |conf c (return t) --> conf c (LIOTCB t)| }
\and
\inferrule[bind]
{ }
{ |conf c (E[(LIOTCB t1) >>= t2]) --> conf c (t2 t1)| }
\and
\inferrule[getLabel]
{ |c = (lcurr, ...)|  }
{
|conf c (E[getLabel]) --> conf c (E[return lcurr])|
}
\end{mathpar}
\caption{Reduction rules for base \lio.}
\end{figure}



\begin{code}
Ep  ::= Ep t | fix Ep | if Ep then t else t 
      | Ep lop t | v lop Ep
E  ::= []| Ep | E >>= t 
\end{code}

\Red{
Maybe useful somewhere else:
The design constraints imposed by the library approach has led to a
novel point in the design space of language-level IFC systems---when
compared to more traditional IFC systems---that incorporates ideas
from previous IFC operating systems.
}
