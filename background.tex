\section{Introduction to LIO}
\label{sec:background}
\hl{TODO: make sure we explain TCB is not part of the surface syntax}
\hl{DONE, in the description of Figure 2}

%\concept{LIO library as LIO-monad}
LIO is a language-level IFC system, implemented as a library in Haskell.  The
library provides a special API, called the \emph{monad} |LIO|, which 
programmers utilize to write their computations to enforce IFC policies. 
%
%Concretely, LIO provides programmers with a new monad, called |LIO|,
%that is similar to---and is intended to be used in place of---the
%standard Haskell |IO| monad, but additionally monitors and controls
%the flow of information.
%
%In turn, various practical features (e.g., mutable references and
%threads) are implemented as combinators in this monad.
%
%\concept{Current label used to govern flows}

The |LIO| monad essentially implements a purely dynamic execution monitor. More 
specifically, it encapsulates the state necessary to enforce IFC for the computation
under evaluation.
%
Part of this state is the \emph{current floating-label} (or just current label for short).
%
Intuitively, the current label serves a role similar to the program
counter (|pc|) of more-traditional IFC systems
(e.g.,~\cite{FlowCaml}).
%
More specifically, it prevents the current computation from performing 
side-effects compromising confidentiality of data.
Henceforth, we assume that all computations are encoded in |LIO|.

%
%For instance, if the current label is |lcurr|, LIO restricts the
%computation to only reading data labeled |l_d|, where |l_d canFlowTo
%lcurr|.
%
%For instance, it restricts the computation from writing to entities
%labeled |l_e|, unless |lcurr canFlowTo l_e|.

%\concept{Current label is label on all in scope}
Conceptually speaking, to soundly reason about IFC, every piece of data 
 \emph{must} be labeled, i.e., associated with a security level.
%
%This includes literals, terms, labels, execution contexts, etc.
%
%However and in contrast to language-based systems (e.g.,
%Jif~\cite{myers:jif}, FlowCaml~\cite{FlowCaml}, Breeze~\cite{Breeze},
%etc.), where every value is explicitly labeled, values in LIO are
%Haskell values and thus do not have explicit labels.
%
%(LIO cannot explicitly label every Haskell value without modifying the
%language runtime!)
%
 Different from other language-based systems (e.g.~\cite{myers:jif,FlowCaml}),
 LIO takes a coarse-grained approach and uses the current label to protect all
 values in scope, i.e., in LIO, the current label |lcurr| is the label on all
 the non-explicitly labeled values in the context of a computation---an idea taken
 from IFC operating systems~\cite{efstathopoulos:asbestos,zeldovich:histar}.
%
%% It is repetitive with the previous paragraph
%Since the current label is used to restrict the current computation
%from performing arbitrary side-effects---this ensures that that the
%confidentiality (and integrity) of all values in scope are preserved.
%

%\concept{Floating label}

Further borrowing from IFC operating systems (namely,
HiStar~\cite{zeldovich:histar}), LIO raises the current label to
protect newly read data in scope.
%
That is, the current label is raised to ``float'' above the labels of
all the objects read by the current computation.
(Hence the name ``floating-label.'')
% 
Raising the current label allows computations to flexibly read data,
at the cost of being more limited in where they can subsequently
write.
%
Concretely, a computation with current label |lcurr| can read data
labeled |l_d| by raising its current label to |lcurr' = lcurr lub
l_d|, but can thereafter only write to entities labeled |l_e| if
|lcurr' canFlowTo l_e|.
%
For example, LIO allows a public computation to read secret data by
raising |lcurr| from |low| to |high|. Importantly, the new current label
prevents the computation from subsequently writing to public entities.

% \concept{Labeled objects}
% \hl{TODO:talk about labeled values and references}
% \hl{Ale:I think it is not needed, it can be done along the way}

\subsection{\lio: A coarse-grained IFC calculus}
 
%\concept{\lio{} syntax}

\begin{figure}[t]
\small
\centering
%format Values  = "\mathrm{Values}"
%format Terms   = "\mathrm{Terms}"
%format Types   = "\mathrm{Types}"
%format LOps    = "\mathrm{Ops}_"lattice
\begin{code}
Values  v    ::=  true | false | () | \x.t | lattice | LIOTCB t
Terms   t    ::=  v | x | t t | fix t | if t then t else t
               |  t lop t | return t | t >>= t | getLabel
Types   tau  ::=  Bool | () | tau -> tau | lattice | LIO tau  
LOps    lop  ::=  lub | glb | canFlowTo
\end{code}
\caption{\label{fig:sos:base}
          Base \lio{} syntactic categories.}
\end{figure}

We describe a calculus which gives precise semantics to |LIO| and the role of
the current label when preserving confidentiality. More technically, we consider
LIO as an extended simply-typed, call-by-name $\lambda$-calculus, called \lio.
%
The formal syntax of the core \lio{} calculus, parametric in the label
type |lattice|, is given in Fig.~\ref{fig:sos:base}.
%
Syntactic categories |v|, |t|, and |tau| represent values, terms, and
types, respectively.
%
Values include standard primitives (Booleans, unit, and $\lambda$-abstractions)
and terminals corresponding to labels (|lattice|) and monadic values (|LIOTCB
t|).\footnote{ We restrict our formalization to computations implemented in the
  |LIO| monad and only consider Haskell features relevant to IFC, similar to the
  presentation of LIO in~\cite{stefan:lio,stefan:addressing-covert}.  } We note
that values of the form |LIOTCB t| denote computations subject to security
checks. In fact, security checks might only occur when evaluating such values.
%
Terms are composed of standard constructs (values, variables |x|, function
application, the |fix| operator, and conditionals), terminals corresponding to
label operations (|t lop t|, where |lub| is the join, |glb| is the meet, and
|canFlowTo| is the partial-order on labels), standard monadic operators (|return
t| and |t >>= t|), and |getLabel|, to be explained below.
%
Terms with the annotation |TCB| are not part of the surface syntax,
i.e. they are not made available to programmers -- these syntax nodes
are only used internally in the semantics.
%
Types consist of Booleans, unit, function types, labels, and |LIO|
computations; since the \lio{} type system is standard, we do not
discuss it further.

% Monadic operators 
\begin{wrapfigure}{r}{0.4\columnwidth}
\vspace{-15pt}
\begin{code}
do  x <- t 
    return (x+1) 
\end{code}
\vspace{-15pt}
\caption{\label{fig:do}|do|-notation}
\end{wrapfigure}
Monadic terms are used to create complex LIO computations from simpler
ones. Term |return t| produces a computation which simply returns the value
denoted by |t|. The monadic term |>>=|, called \emph{bind}, is used to sequence
LIO programs. Specifically, term |t >>= (\x.t')| takes the result produced by
term |t| and gives it as an argument to the function |\x.t'|.  This operator
allows computation |t'| to depend on the value produced by |t|.  We sometimes
use Haskellâ€™s |do|-notation to write such computations. For example, the term |t
>>= \x.return (x+1)|, which describes the computation adding one to the value
produced by the term |t|, is written as in Figure \ref{fig:do}.

%\concept{configurations}
%The reduction rules for monadic terms deserve some attention.
%
%Rather than modeling state, such as the current label, as
%purely-functional monad layers, we take an operational and
%more-imperative approach by modeling state as a separate component.
%
Following a more-imperative approach, we model the state kept by LIO as a
separate component in a configuration.
%in an operational and
%more-imperative style as a separate component.
Specifically, a top-level computation is a \emph{configuration} of the form
|conf c t|, where |t| is the monadic term and |c| is the state associated with
the term. We partially specify the state of \lio as being composed of the
current label |lcurr|, i.e., |c = (lcurr, ...)| where |...| denotes other parts
of the state not relevant at this point.

%
%(Under this definition, \lio{} type-judgements have the form | G, c :-
%t : LIO tau|, where |G| is the usual type environment.)
%
% As a result of this encoding, the definition for |return| and |(>>=)|
% are trivial: the former simply reduces to a monadic value by wrapping
% the term with the |LIOTCB| constructor, while the latter evaluates the
% left-hand term and supplies the result to the right-hand term, as
% usual.


\begin{figure}[t] % sos:rules-abr
\small
\begin{code}
Ep  ::= Ep t | fix Ep | if Ep then t else t | Ep lop t | v lop Ep
E   ::= []| Ep | E >>= t 
\end{code}
\begin{mathpar}
%{\centering ...}
\\
\inferrule[getLabel]
{ |c = (lcurr, ...)|  }
{
|conf c (E[getLabel]) --> conf c (E[return lcurr])|
}
\end{mathpar}
\caption{Evaluation contexts and |getLabel| reduction rule.\label{fig:sos:rules-abr}}
\end{figure}

%\concept{eval ctx}
We use evaluation contexts in the style of Felleisen and Hieb to specify the
reduction rules for \lio~\cite{felleisen1992revised}.
%
Figure~\ref{fig:sos:rules-abr} defines the evaluation contexts |Ep| for pure
terms and |E| for monadic ones, as well as giving an
example of a reduction rule for the monadic term |getLabel|, which retrieves
the current label.
%

%
The evaluation contexts are standard; we solely highlight that monadic terms are
evaluated only at the outermost use of bind (|E >>= t|), as in Haskell.  
Rule \ruleref{getLabel} defines the LIO library function |getLabel|.
%
\hl{The following sentence seems out of place, like it's missing a follow-up sentence.}
Recall that it is the current label that protects all the values in scope.
% 
The rest of the reduction rules can be found in the Appendix~\ref{sec:app:sem}.
%


%
%However, since neither |return| nor |>>=| perform any security checks,
%all LIO functions must inspect the current label to enforce IFC.
%
%Ale: for space reasons only 
% For example, we can define a |publish| function that writes the
% supplied value to a public channel in terms of a |publishTCB| function
% (that unsafely writes any data to the channel) as follows:
% \begin{code}
% publish v = do  lcurr <- getLabel 
%                 if (lcurr canFlowTo low)  then  publishTCB v
%                                           else  return ()
% \end{code}
% Hence, if the current computation has read any sensitive data---and
% thus the current label is |high|---it cannot subsequently leak it with
% publish.\footnote{
%   As with other TCB functions, we assume that |publishTCB| is not part
%   of the surface syntax.
% }

\subsection{Labeled values}

%\concept{|lcurr| is too coarse-grained}
Using |lcurr| as the label on all terms in scope makes it trivial to deal with
implicit flows. Branch conditions, which are simply values of type |Bool|, are
already implicitly labeled with |lcurr|. Consequently, all the subsequent writes cannot leak
this bit---the current label restricts all the possible writes (even those in
a branch).
%reason about issues that have traditionally been hard to deal with in
%IFC systems.
%
%For example, LIO does not have to explicitly handle the implicit flows
%problem: branch conditions (which are are simply values of type
%|Bool|) are labeled |lcurr|, and thus any subsequent writes cannot leak
%the sensitive bit---the current label is used when governing all
%writes (even those in a branch).
%
This coarse-grained labeling approach suffers from a severe restriction: a piece
of code cannot, for example, %and independently of any secret,
write the public
constant |42| to a public channel labeled |low| after observing secret
data, even if this constant is independent from the secret---once secret data is read, the current label is raised to |high| thereby
``over tainting'' the public data in scope.

\begin{figure}[t] % labeled
\small
\begin{code}
v    ::= cdots  | LabeledTCB l t
t    ::= cdots  | label t t | unlabel t | labelOf t | upgrade t t
tau  ::= cdots  | Labeled tau
Ep   ::= cdots  | label Ep t | unlabel Ep | labelOf Ep
                | upgrade Ep t | upgrade v Ep
\end{code}

\begin{mathpar}
\inferrule[label]
{ |c = (lcurr, ...)|\\
  |lcurr canFlowTo l| 
}
{
|conf c (E[label l t]) --> conf c (E[return (LabeledTCB l t)])|
}
\and

\inferrule[unlabel]
{ |c = (lcurr, ...)|\\
  |lcurr' = lcurr lub l |\\
  |c' = (lcurr', ...)|
}
{
|conf c (E[unlabel (LabeledTCB l t)]) --> conf c' (E[return t])|
}
\and
\inferrule[labelOf]
{ }
{ |Ep[labelOf (LabeledTCB l t)] ~> Ep[l]| }
\and
\inferrule[upgrade]
{ |c = (lcurr, ...)|\\
  |l_u = lcurr lub l lub l'|}
{ |conf c (E[upgrade (LabeledTCB l t) l']) --> conf c (E[label l_u t])| }
\end{mathpar}
\caption{Extending \lio{} with labeled values\label{fig:sos:labeled}.}
\end{figure}

 
%\concept{labeled values}
To address this limitation, LIO provides |Labeled| values, a means to 
explicitly associate labels to terms, irrespective of the current label.
%
Intuitively, a term can be %heterogeneously 
labeled by a label at least as restrictive as |lcurr|. 
%  if we can ``transfer'' protection from the current label
% to this |Labeled| value (e.g., by ensuring that the protected value
% cannot be inspected in a (future) less-sensitive context).
%
To this end, we extend \lio{} as shown in Figure~\ref{fig:sos:labeled}.

%\concept{label}
The |label| terminal (|label t t|) is used to explicitly label a term.
%
As rule \ruleref{label} shows, the function associates the supplied
label |l| with term |t| by wrapping the term with the |LabeledTCB|
constructor.
%
Importantly, it first asserts that the new label (|l|) used to
protect |t| is at least as restricting as the current label 
(|lcurr canFlowTo l|).
 
%\concept{unlabel}
Dually, terminal |unlabel| unwraps explicitly labeled values.
%
As defined in rule \ruleref{unlabel}, given a labeled value
|LabeledTCB l t|, the function returns the wrapped term |t|.
%
Since the returned term is no longer explicitly labeled by |l|, and
is instead protected by the current label, |lcurr| must be at least
as restricting as |l|.
%
To ensure this, the current label is raised from |lcurr| to |lcurr lub
l|---this captures the fact that the remaining computation might
depend on |t|. 
%
Moreover, this rule highlights the fact that the current label always
``floats'' above the labels of the values observed by the current
computation.

%\concept{labelOf}
The |labelOf| function provides a means for inspecting the label of a
labeled value.
%
As detailed by reduction rule \ruleref{labelOf}, given a labeled value
|LabeledTCB l t| the function returns the label |l| protecting term
|t|.
%
This allows code to check the label of a labeled value before deciding
to unlabel it, and thereby raise the current label.
%
It it worth noting that regardless of the current label in the
configuration, the label of a labeled value can be inspected---hence
labels are effectively ``public.''\footnote{
In fact labels are actually protected by the current label, but since
code can always observe objects labeled at the current label this is
akin to being public.
}

%\concept{upgrade}
Finally, |upgrade| allows a piece of code to raise the label of a
labeled value.
%
Since labeled values are immutable, this function, in effect, produces
another labeled value that is protected by a label that is more restrictive
than the current one.
%
Since LIO has the invariant that a computation can only create or
write to entities above the current label, we use |lcurr| in addition
to the supplied label (|l'|) when upgrading a labeled value.

%\concept{label creep}
Intuitively, we can try to define |upgrade| in terms of existing
terminals by first |unlabel|ing the labeled value and then |label|ing
the result with the join of the current label, existing label and new
label.
%
Unfortunately, using |unlabel| would cause the current label to be
raised, since we now have (potentially) sensitive data in scope, thus
preventing the computation from performing subsequent side effects on
less sensitive locations.
%
% Unfortunately, these semantics are different; |unlabel| raises the
% current label and, while the |label| will succeed in creating a new
% labeled value with the desired label, the current label cannot be
% lowered to the label at the point before the |unlabel|, since we now
% have (potentially) more sensitive data in scope.
%
This raising of the current label to a point where the computation can
no longer perform useful tasks is known as \emph{label
creep}~\cite{sabelfeld:language-based-iflow}.
%
% Label creep does not compromise security, since the current
% label still protects all data in lexical scope.
%
Despite not compromising security, label creep makes LIO overly
restrictive for building practical applications. 
%---in general, being able to perform computations on
%sensitive data without raising the current label is crucial to
%building practical applications.

%\concept{toLabeled}
To avoid label creep, LIO provides the |toLabeled| function which
allows the current label to be \emph{temporarily} raised during the execution of 
a given computation. 
% and subsequently restore it. 
% executes an
% |LIO| action (that may raise the current label) and subsequently
% restores the current label.
%
We extend the terms and the pure evaluation context with |t
::= cdots inlinesep toLabeled t t| and |Ep ::= cdots inlinesep
toLabeled Ep t|, respectively, and give the precise semantics of
|toLabeled| as follows:
%
\begin{mathpar}
\inferrule[toLabeled]
{
|c = (lcurr, ...)|\\
|lcurr canFlowTo l| \\
|conf c t ==> conf c' (LIOTCB t')| \\
|c' = (lcurr', ...)|\\
|lcurr' canFlowTo l|\\
|c'' = c merge c'|
}
{
|conf c (E[toLabeled l t]) --> conf c'' (E[label l t'])|
}
\end{mathpar}
%
Intuitively, if the current label at the point of executing 
|toLabeled l t| is |lcurr|, |toLabeled| evaluates |t| to completion 
(|conf c t ==> conf c' (LIOTCB t')|) and
restores the current label to |lcurr|, i.e., |toLabeled| provides a
separate context in which |t| is evaluated.
%
(Here, the state merge function |merge| is defined as: |c merge c' @=
c'|, in the next section we present an alternative definition.)
%
Returning the result of evaluating |t| directly (i.e. |conf c (E[toLabeled l t]) --> conf c'' (E[t'])|) 
would allow for trivial leaks; therefore, |toLabeled| labels |t'| with |l| 
(|conf c'' (E[label l t']|).
%
This effectively states that the result of |t| is protected by label
|l|, as opposed to the current label at the point |t| completed.
%
Importantly, this requires that the result not be more sensitive than
|l|.

% %% This can be removed!
% \concept{upgrade with toLabeled}
% Note that with |toLabeled| we can now define |upgrade| as follows:
% \begin{code}
% upgrade t1 t2 @= getLabel >>= \l.
%   toLabeled (labelOf t1 lub l lub t2) (unlabel t1)
% \end{code}
% However, since |toLabeled| needs to be modified to accommodate for
% flow-sensitive references with auto-upgrading, we leave our definition
% |upgrade| as a given in Figure~\ref{fig:sos:labeled}.\footnote{
% In section~\ref{sec:flow-sensitive}, we define an alternative version
% of |toLabeled|, in terms of which we can define the upgrade function
% such that its semantics are equivalent to those given
% Figure~\ref{fig:sos:labeled}. This definition is:
% |upgrade t1 t2 @= getLabel >>= \l.
%   toLabeled' (labelOf t1 lub l lub t2) nil (unlabel t1)|
% }


\subsection{Labeled references}

%\concept{FI refs}
To complete the description of LIO, we extend our \lio{} calculus  with
mutable, flow-insensitive references.
%
Conceptually, flow-insensitive references are simply mutable |Labeled| values.
%
Like labeled values, the label of a reference is immutable and serves to
protect the underlying term.
%
(Recall that |upgrade| provides the effect of raising the label of a value by simply
producing another immutable value.)
%
The immutable label makes the semantics straightforward: writing a term to a
reference amounts to ensuring that the reference label is as restrictive as the current
label (i.e., the reference label must be above the current label);
reading from a reference taints the current label with the reference label.
%
% In this paper we also introduce a flow-sensitive version of
% references, where the reference label itself is also mutable; the
% semantics for these references are described in
% Section~\ref{sec:flow-sensitive}.

\begin{figure}[t]
\small
\begin{code}
v    ::= cdots  | LIORefTCB I l a
t    ::= cdots  | newRef s t t | writeRef s t t | readRef s t
                | labelOfR s t
tau  ::= cdots  | LIORef s tau
Ep   ::= cdots  | newRef s Ep t | writeRef s Ep t | readRef s Ep 
                | labelOfR s Ep
\end{code}

\begin{mathpar}
\inferrule[newRef-|I|]
{ |c = (lcurr, mI, ...)| \and 
  |lcurr canFlowTo l| \ \\
  |mI' = mI[a mapsto LabeledTCB l t]| \and   
  |c' = (lcurr, mI', ...)|
}
{ |conf c (E[newRef I l t]) --> conf c' (E[return (LIORefTCB I l a)])| }
{ |fresh a| }

\and

\inferrule[readRef-|I|]
{ |c = (lcurr, mI, ...)|
}
{ |conf c (E[readRef I (LIORefTCB I l a)]) --> conf c (E[unlabel mI(a)])| }


\and
\inferrule[writeRef-|I|]
{ |c = (lcurr, mI, ...)| \and 
  |lcurr canFlowTo l| \\
  |mI' = mI[a mapsto LabeledTCB l t]| \and 
  |c' = (lcurr, mI', ...)|
}
{ |conf c (E[writeRef I (LIORefTCB I l a) t]) --> conf c' (E[return ()])| }


\and

\inferrule[labelOf-|I|]
{ }
{ |Ep[labelOfR I (LIORefTCB I l a)]) --> Ep[l]| }
\end{mathpar}
\caption{Extending \lio{} with references. The reduction rules for
flow-sensitive (|S|) references are given in Figure~\ref{fig:fs-exts-semantics}.
\label{fig:sos:refs}}
\end{figure}
%\concept{new syntax}
%
The syntactic extensions to our calculus are shown in Fig.~\ref{fig:sos:refs}.
%
We use subscript |s ::= I inlinesep S| to respectively distinguish
flow-insensitive and flow-sensitive productions (the former are explained in this
section, and the latter in Section \ref{sec:flow-sensitive}.)
%, the semantics for latter are
%described in Section~\ref{sec:flow-sensitive}.
%
In the semantics, we extend configurations to involve a reference (memory) store |mI|: |c = (lcurr, mI, ...)|;
%
|mI| maps memory addresses---spanned over by metavariable |a|---to |Labeled|
values.
%
%% Second, we add a flow-insensitive reference value (|LIORefTCB I l a|), and
%% terms for creating (|newRef s|), reading (|readRef s|), modifying (|writeRef
%% s|), and inspecting the label of (|labelOfR s|) a reference.
%

%\concept{semantics for refs}
%
When creating a flow-insensitive reference, |newRef I l t| creates a labeled
value that guards |t| with label |l| (|LabeledTCB l t|) and stores it in the
memory store at a new, fresh, address |a| (|mI[a mapsto LabeledTCB l t]|).
%
Subsequently, the function returns a value of the form |LIORefTCB I l a| (with type
|LIORef I|) which simply encapsulates the reference label and address where the
term is stored.
%
Rule \ruleref{readRef-|I|} specifies the semantics for reading a
labeled reference; reading the term stored at address |a| simply
amounts to unlabeling the value |m(a)| stored at the underlying
address (|unlabel mI(a)|).
%
Terminal |writeRef I| is used to update the memory store with a new labeled term
|t| for the reference at location |a|.
%
Note that |writeRef I| \emph{leaves the label of the reference intact}, i.e., the
label of a flow-insensitive reference is never changed, but in turn requires
that the current label not be any more sensitive than the reference label
(|lcurr canFlowTo l|).
%
Consequently, |labelOfR I| can always be used to inspect the label of such a
reference.
%

%\concept{updated |merge| }
We finally remark that any references created in a |toLabeled| block might 
outlive the |toLabeled| block computation.
%
Hence, we update the merge function used in rule~\ruleref{toLabeled} to
accommodate for references as follows:
|(lcurr, mI, ...) merge (lcurr', mI', ...) = (lcurr, mI', ...)|.
%
In other words, the merge function restores the current label to that of the
outer configuration, but retains the latest memory store.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%maybe useful:%\begin{figure}[h!]
%%maybe useful:%\small
%%maybe useful:%\begin{mathpar}
%%maybe useful:%\inferrule
%%maybe useful:%{ |conf c t --> conf c' t'| }
%%maybe useful:%{ |conf c (E[t]) --> conf c' (E[t'])| }
%%maybe useful:%\and
%%maybe useful:%\inferrule
%%maybe useful:%{ |Ep[t] ~> Ep[t']| }
%%maybe useful:%{ |conf c (Ep[t]) --> conf c (Ep[t'])| }
%%maybe useful:%\and
%%maybe useful:%\inferrule
%%maybe useful:%{ |t ~> t'| }
%%maybe useful:%{ |Ep[t] ~> Ep[t']| }
%%maybe useful:%\end{mathpar}
%%maybe useful:%\caption{Evaluation relations \hl{ Maybe useful somewhere; appendix? } }
%%maybe useful:%\end{figure}
%%maybe useful:%
%%maybe useful:%
%%maybe useful:%\hl{
%%maybe useful:%Maybe useful somewhere else:
%%maybe useful:%The design constraints imposed by the library approach has led to a
%%maybe useful:%novel point in the design space of language-level IFC systems---when
%%maybe useful:%compared to more traditional IFC systems---that incorporates ideas
%%maybe useful:%from previous IFC operating systems.
%%maybe useful:%}
