\section{Introduction to LIO}
\label{sec:background}

LIO is a language-level IFC system, implemented as a Haskell
library.
%
Concretely, LIO provides programmers with a new monad, called |LIO|,
that is similar to---and is intended to be used in place of---the
standard Haskell |IO| monad, but additionally monitors and controls
the flow of information.
%
In turn, various practical features (e.g., mutable references and
threads) are implemented as combinators in this monad.
%
Henceforth we assume that all computations are encoded in |LIO|.

The |LIO| monad encapsulates the state necessary to enforce IFC for
the computation under evaluation, part of which is the ``current
label.''
%
Intuitively, the current label serves a role similar to the program
counter (|pc|) in other IFC systems (e.g.,~\cite{FlowCaml}).
%
Namely, it restricts the current computation from performing arbitrary
side-effects.
%
For instance, if the current label is |lcurr|, LIO restricts the
computation to only reading data labeled |l_d|, where |l_d canFlowTo
lcurr|.
%
Similarly, it restricts the computation from writing to entities
labeled |l_e|, unless |lcurr canFlowTo l_e|.

To soundly reason about IFC, every object in an IFC system \emph{must}
be labeled.
%
This includes literals, terms, labels, execution contexts, etc.
%
However and in contrast to language-based systems (e.g.,
Jif~\cite{myers:jif}, FlowCaml~\cite{FlowCaml}, Breeze~\cite{Breeze},
etc.), where every value is explicitly labeled, values in LIO are
Haskell values and thus do not have explicit labels.
%
This is a direct consequence of taking a library-based approach: LIO
cannot explicitly label every Haskell value without modifying the
language runtime.
%
Instead, and like several IFC operating
systems~\cite{efstathopoulos:asbestos,zeldovich:histar}, LIO takes a
coarse-grained approach and use the current label to protect all
values in scope, i.e., in LIO, the current label |lcurr| is the label
on all ``unlabeled'' values.
%
Since the current label is used to restrict the current computation
from performing arbitrary side-effects---this ensures that that the
confidentiality (and integrity) of all values in scope are preserved.

Further borrowing from IFC operating systems (namely,
HiStar~\cite{zeldovich:histar}), LIO raises the current label to
protect newly read data that is incorporated in scope.
%
In other words, the current label is adjusted to ``float'' above the
labels of all the objects read by the current computation.
% 
Raising the current label allows computations to flexibly read data,
at the cost of being more limited in where they can subsequently
write.
%
Concretely, a computation with current label |lcurr| can read data
labeled |l_d| by raising its current label to |lcurr' = lcurr lub
l_d|, but can thereafter only write to entities labeled |l_e| if
|lcurr' canFlowTo l_e|.
%
For example, LIO allows a public computation to read secret data by
raising |lcurr| from |L| to |H|. Importantly, the new current label
prevents the computation from subsequently writing to public entities.
 
\subsection{\lio: A corase-grained IFC calculus}
 
To give precise semantics, we consider LIO as an extended
simply-typed, call-by-name $\lambda$-calculus, called \lio.
%
The formal syntax of the core \lio{} calculus, parametric in the label
type |lattice|, is given in Fig.~\ref{fig:language:base}.
%
Syntactic categories |v|, |t|, and |tau| represent values, terms, and
types, respectively.
%
Values include standard primitives (Booleans, unit,
and $\lambda$-abstractions) and terminals corresponding to labels
(|lattice|) and monadic values (|LIOTCB tau|).\footnote{
We restrict our formalization to computations implemented in the |LIO|
monad and only consider Haskell features relevant to IFC, similar to
the presentation of LIO in~\tocite{jfptechreport}.
}
%
Terms constitute standard constructs (values, variables |x|, function
application, the |fix| operator, and conditionals), terminals
corresponding to label operations (|t lop t|, where |lub| is the join,
|glb| is the meet, and |canFlowTo| is the partial-order on labels),
standard monadic operators (|return t| and |t >>= t|), and |getLabel|,
describe below.
%
Types consist of Booleans, unit, function types, labels, and |LIO|
computations; since the \lio{} type system is standard, we do not
discuss it further.

\begin{figure}
\centering
%format Values  = "\mathrm{Values}"
%format Terms   = "\mathrm{Terms}"
%format Types   = "\mathrm{Types}"
%format LOps    = "\mathrm{Ops}_"lattice
\begin{code}
Values  v    ::=  true | false | () | \x.t | lattice | LIOTCB t
Terms   t    ::=  v | x | t t | fix t | if t then t else t
               |  t lop t | return t | t >>= t | getLabel
Types   tau  ::=  Bool | () | tau -> tau | lattice | LIO tau  
LOps    lop  ::=  lub | glb | canFlowTo
\end{code}
\caption{Base \lio{} syntactic categories.
\label{fig:language:base}}
\end{figure}

\hl{HERE}

An LIO program is a \emph{configuration} of the form |conf c t|, where
|t| is the monadic term under evaluation, such that |:- t : LIO tau|,
and |c| is state associated with the computation.
%
The state |c| is a tuple that contains the current label |lcurr|
memory stores, etc. i.e., |c = (lcurr, ...)|.
%

\begin{figure}[ht]
\begin{mathpar}
\inferrule
{ |conf c t --> conf c' t'| }
{ |conf c (E[t]) --> conf c' (E[t'])| }
\and
\inferrule
{ |Ep[t] ~> Ep[t']| }
{ |conf c (Ep[t]) --> conf c (Ep[t'])| }
\and
\inferrule
{ |t ~> t'| }
{ |Ep[t] ~> Ep[t']| }
\end{mathpar}
\caption{Evaluation relations}
\end{figure}


\begin{figure}[t] % sos:base
\begin{mathpar}
\inferrule[app]
{ } { |Ep[(\x.t1) t2] ~> Ep[{ t2 / x } t1]| }
\and
\inferrule[fix]
{ } { |Ep[fix (\x.t)] ~> Ep[{fix (\x.t) / x } t|] }
\and
\inferrule[ifTrue]
{ } { |Ep[if true then t2 else t3] ~> Ep[t2]| }
\and
\inferrule[ifFalse]
{ } { |Ep[if false then t2 else t3] ~> Ep[t3]| }
\and
\inferrule[lOp]
{ | denot ( l3 = l1 lop l2 ) | }
{ |Ep[l1 lop l2] ~> Ep[l3]| }
\and
\inferrule[return]
{ } { |conf c (return t) --> conf c (LIOTCB t)| }
\and
\inferrule[bind]
{ }
{ |conf c (E[(LIOTCB t1) >>= t2]) --> conf c (t2 t1)| }
\and
\inferrule[getLabel]
{ |c = (lcurr, ...)|  }
{
|conf c (E[getLabel]) --> conf c (E[return lcurr])|
}
\end{mathpar}
\caption{Reduction rules for base \lio.}
\end{figure}

\begin{code}
Ep  ::= Ep t | fix Ep | if Ep then t else t 
      | Ep lop t | v lop Ep
E  ::= []| Ep | E >>= t 
\end{code}

\subsection{Labeled values}

\begin{code}
v    ::= cdots  | LabeledTCB l t
t    ::= cdots  | label t t | unlabel t | labelOf t
                | upgrade t t
tau  ::= cdots  | Labeled tau

Ep   ::= cdots  | label Ep t | unlabel Ep | labelOf Ep
                | upgrade Ep t | upgrade v Ep
\end{code}

\begin{figure}[t] % labeled
\begin{mathpar}
\inferrule[label]
{ |c = (lcurr, ...)|\\
  |lcurr canFlowTo l ~> true| 
}
{
|conf c (E[label l t]) --> conf c (E[return (LabeledTCB l t)])|
}
\and

\inferrule[unlabel]
{ |c = (lcurr, ...)|\\
  |lcurr lub l ~> lcurr'|\\
  |c' = (lcurr', ...)|
}
{
|conf c (E[unlabel (LabeledTCB l t)]) --> conf c' (E[return t])|
}
\and
\inferrule[labelOf]
{ }
{ |Ep[labelOf (LabeledTCB l t)] ~> Ep[l]| }
\and
\inferrule[upgrade]
{ |c = (lcurr, ...)|\\
  |t' = lcurr lub l lub l'|}
{ |conf c (E[upgrade (LabeledTCB l t) l']) --> conf c (E[label t' t])| }
\end{mathpar}
\caption{Semantics for labeled values\label{fig:sos:labeled}.}
\end{figure}

Note that with |toLabeled| we can define |upgrade| as follows:
\begin{code}
upgrade t1 t2 @= getLabel >>= \l.
  toLabeled (labelOf t1 lub l lub t2) (unlabel t1)
\end{code}
Unfortunately, because |toLabeled| needs to be modified to accomodate
for flow-sensitive references and so we provide |upgrade| as a
primitive.\footnote{
In section~\ref{sec:flow-sensitive}, we define an alternative
version of |toLabeled|, in terms of which we can define the
upgrade function such that its semantics are equivalent to those
given Figure~\ref{fig:sos:labeled}. This definition is:
|upgrade t1 t2 @= getLabel >>= \l.
  toLabeled' (labelOf t1 lub l lub t2) nil (unlabel t1)|
}

\Red{
Maybe useful somewhere else:
The design constraints imposed by the library approach has led to a
novel point in the design space of language-level IFC systems---when
compared to more traditional IFC systems---that incorporates ideas
from previous IFC operating systems.
}
