\section{Introduction to LIO}
\label{sec:background}

\concept{LIO library as LIO-monad}
LIO is a language-level IFC system, implemented as a Haskell
library.
%
Concretely, LIO provides programmers with a new monad, called |LIO|,
that is similar to---and is intended to be used in place of---the
standard Haskell |IO| monad, but additionally monitors and controls
the flow of information.
%
In turn, various practical features (e.g., mutable references and
threads) are implemented as combinators in this monad.
%

\concept{Current label used to govern flows}
The |LIO| monad encapsulates the state necessary to enforce IFC for
the computation under evaluation.
%
Part of this state is the ``current label.''
%
Intuitively, the current label serves a role similar to the program
counter (|pc|) of more-traditional IFC systems
(e.g.,~\cite{FlowCaml}).
%
Namely, it restricts the current computation from performing arbitrary
side-effects.
%
For instance, if the current label is |lcurr|, LIO restricts the
computation to only reading data labeled |l_d|, where |l_d canFlowTo
lcurr|.
%
Similarly, it restricts the computation from writing to entities
labeled |l_e|, unless |lcurr canFlowTo l_e|.

\concept{Current label is label on all in scope}
To soundly reason about IFC, every object in an IFC system \emph{must}
be labeled.
%
This includes literals, terms, labels, execution contexts, etc.
%
However and in contrast to language-based systems (e.g.,
Jif~\cite{myers:jif}, FlowCaml~\cite{FlowCaml}, Breeze~\cite{Breeze},
etc.), where every value is explicitly labeled, values in LIO are
Haskell values and thus do not have explicit labels.
%
(LIO cannot explicitly label every Haskell value without modifying the
language runtime!)
%
Instead, and like several IFC operating
systems~\cite{efstathopoulos:asbestos,zeldovich:histar}, LIO takes a
coarse-grained approach and use the current label to protect all
values in scope, i.e., in LIO, the current label |lcurr| is the label
on all ``unlabeled'' values.
%
Since the current label is used to restrict the current computation
from performing arbitrary side-effects---this ensures that that the
confidentiality (and integrity) of all values in scope are preserved.
%
(Henceforth, we assume that all computations are encoded in |LIO|.)

\concept{Floating label}
Further borrowing from IFC operating systems (namely,
HiStar~\cite{zeldovich:histar}), LIO raises the current label to
protect newly read data that is incorporated in scope.
%
That is, the current label is raised to ``float'' above the labels of
all the objects read by the current computation.
(Hence the name ``floating-label.'')
% 
Raising the current label allows computations to flexibly read data,
at the cost of being more limited in where they can subsequently
write.
%
Concretely, a computation with current label |lcurr| can read data
labeled |l_d| by raising its current label to |lcurr' = lcurr lub
l_d|, but can thereafter only write to entities labeled |l_e| if
|lcurr' canFlowTo l_e|.
%
For example, LIO allows a public computation to read secret data by
raising |lcurr| from |L| to |H|. Importantly, the new current label
prevents the computation from subsequently writing to public entities.

\concept{Labeled objects}
\hl{TODO:talk about labeled values and references}
 
\subsection{\lio: A corase-grained IFC calculus}
 
\concept{\lio{} syntax}
To give precise semantics, we consider LIO as an extended
simply-typed, call-by-name $\lambda$-calculus, called \lio.
%
The formal syntax of the core \lio{} calculus, parametric in the label
type |lattice|, is given in Fig.~\ref{fig:language:base}.
%
Syntactic categories |v|, |t|, and |tau| represent values, terms, and
types, respectively.
%
Values include standard primitives (Booleans, unit,
and $\lambda$-abstractions) and terminals corresponding to labels
(|l|) and monadic values (|LIOTCB tau|).\footnote{
We restrict our formalization to computations implemented in the |LIO|
monad and only consider Haskell features relevant to IFC, similar to
the presentation of LIO in~\tocite{jfptechreport}.
}
%
Terms are composed of standard constructs (values, variables |x|,
function application, the |fix| operator, and conditionals), terminals
corresponding to label operations (|t lop t|, where |lub| is the join,
|glb| is the meet, and |canFlowTo| is the partial-order on labels),
standard monadic operators (|return t| and |t >>= t|), and |getLabel|,
describe below.
%
Types consist of Booleans, unit, function types, labels, and |LIO|
computations; since the \lio{} type system is standard, we do not
discuss it further.

\begin{figure}
\small
\centering
%format Values  = "\mathrm{Values}"
%format Terms   = "\mathrm{Terms}"
%format Types   = "\mathrm{Types}"
%format LOps    = "\mathrm{Ops}_"lattice
\begin{code}
Values  v    ::=  true | false | () | \x.t | lattice | LIOTCB t
Terms   t    ::=  v | x | t t | fix t | if t then t else t
               |  t lop t | return t | t >>= t | getLabel
Types   tau  ::=  Bool | () | tau -> tau | lattice | LIO tau  
LOps    lop  ::=  lub | glb | canFlowTo
\end{code}
\caption{Base \lio{} syntactic categories.
\label{fig:language:base}}
\end{figure}

\concept{eval ctx}
We use operational semantics with evaluation contexts in the style of
Felleisen and Hieb to specify the reduction rules for \lio~\tocite{}.
%
Figure~\ref{fig:sos:base} defines the reduction rules for the base
calculus with an evaluation context for pure
terms (|Ep|) and one for monadic terms (|E|).
%
The evaluation context are standard; we solely highlight that terms
are evaluated only when used in the top-level context (|E|), as in
Haskell.

\concept{pure red}
Similarly, the reduction rules for pure terms are mostly standard.
%
Only two points are worth noting.
%
First, we define substitution |{t2 / x } t1| in the usual way:
homomorphic on all operators and renaming bound names to avoid
captures. 
%
Second, our label operations |lub|, |glb|, and |canFlowTo| rely on the
label-specific implementation of these lattice operators, as used in
the premise of rule \ruleref{labelOp};
%
we use the meta-level partial function |denot cdot|, which maps terms
to a values, to precisely capure this implementation detail.

\begin{figure}[t] % sos:base
\small
\begin{code}
Ep  ::= Ep t | fix Ep | if Ep then t else t | Ep lop t | v lop Ep
E   ::= []| Ep | E >>= t 
\end{code}

\begin{mathpar}
\inferrule[app]
{ } { |Ep[(\x.t1) t2] ~> Ep[{ t2 / x } t1]| }
\and
\inferrule[fix]
{ } { |Ep[fix (\x.t)] ~> Ep[{fix (\x.t) / x } t|] }
\and
\inferrule[ifTrue]
{ } { |Ep[if true then t2 else t3] ~> Ep[t2]| }
\and
\inferrule[ifFalse]
{ } { |Ep[if false then t2 else t3] ~> Ep[t3]| }
\and
\inferrule[labelOp]
{ | v = denot ( l1 lop l2 ) | }
{ |Ep[l1 lop l2] ~> Ep[v]| }
\and
\inferrule[return]
{ } { |conf c (return t) --> conf c (LIOTCB t)| }
\and
\inferrule[bind]
{ }
{ |conf c (E[(LIOTCB t1) >>= t2]) --> conf c (t2 t1)| }
\and
\inferrule[getLabel]
{ |c = (lcurr, ...)|  }
{
|conf c (E[getLabel]) --> conf c (E[return lcurr])|
}
\end{mathpar}
\caption{Reduction rules for base \lio.\label{lio:sos:base}}
\end{figure}

\concept{monad red}
\hl{here}
The recution rules for monadic terms deserve some attention.

\concept{configurations}
An \lio{} program is a \emph{configuration} of the form |conf c t|,
where |t| is the monadic term under evaluation, i.e., | G, c :- t :
LIO tau| for some type environment |G|, and |c| is state associated
with the computation.
%
The state |c| is a tuple that contains the current label |lcurr|,
among other objects (discussed in later), i.e., |c = (lcurr, ...)|.
%
The relation |conf lcurr ccurr m t  -->  conf lcurr' ccurr' m' t'|
represents a single evaluation step from term |t|, with current label
|lcurr|, current clearance |ccurr|, and memory |m|, to term |t'|, with
current label |lcurr'|, current clearance |ccurr'|, and memory |m'|.
%
We write |@-->*| for the reflexive and transitive closure of |@-->|.
%
For the moment, we ignore the clearance and memory in the
configuration, and the subindexes in the transition relation.
%
The reduction rules for the core |LIO| operations are given in
Fig.~\ref{fig:sos:lio}.
%
The rules for |return| and |(>>=)| are trivial and standard---recall
that all IFC checks are performed by individual |LIO| actions.
%
Rule \ruleref{getLabel} defines the |LIO| library function for
retrieving the underlying current label. 



\subsection{Labeled values}

\begin{code}
v    ::= cdots  | LabeledTCB l t
t    ::= cdots  | label t t | unlabel t | labelOf t
                | upgrade t t
tau  ::= cdots  | Labeled tau

Ep   ::= cdots  | label Ep t | unlabel Ep | labelOf Ep
                | upgrade Ep t | upgrade v Ep
\end{code}

\begin{figure}[t] % labeled
\small
\begin{mathpar}
\inferrule[label]
{ |c = (lcurr, ...)|\\
  |lcurr canFlowTo l ~> true| 
}
{
|conf c (E[label l t]) --> conf c (E[return (LabeledTCB l t)])|
}
\and

\inferrule[unlabel]
{ |c = (lcurr, ...)|\\
  |lcurr lub l ~> lcurr'|\\
  |c' = (lcurr', ...)|
}
{
|conf c (E[unlabel (LabeledTCB l t)]) --> conf c' (E[return t])|
}
\and
\inferrule[labelOf]
{ }
{ |Ep[labelOf (LabeledTCB l t)] ~> Ep[l]| }
\and
\inferrule[upgrade]
{ |c = (lcurr, ...)|\\
  |t' = lcurr lub l lub l'|}
{ |conf c (E[upgrade (LabeledTCB l t) l']) --> conf c (E[label t' t])| }
\end{mathpar}
\caption{Semantics for labeled values\label{fig:sos:labeled}.}
\end{figure}

Note that with |toLabeled| we can define |upgrade| as follows:
\begin{code}
upgrade t1 t2 @= getLabel >>= \l.
  toLabeled (labelOf t1 lub l lub t2) (unlabel t1)
\end{code}
Unfortunately, because |toLabeled| needs to be modified to accomodate
for flow-sensitive references and so we provide |upgrade| as a
primitive.\footnote{
In section~\ref{sec:flow-sensitive}, we define an alternative
version of |toLabeled|, in terms of which we can define the
upgrade function such that its semantics are equivalent to those
given Figure~\ref{fig:sos:labeled}. This definition is:
|upgrade t1 t2 @= getLabel >>= \l.
  toLabeled' (labelOf t1 lub l lub t2) nil (unlabel t1)|
}

\begin{figure}[!ht]
\small
\begin{mathpar}
\inferrule[newRef-|I|]
{ |c = (lcurr, mI, ...)|\\
  |lcurr canFlowTo l ~>* true|\\
  |mI' = mI[a mapsto LabeledTCB l t]|\\
  |c' = (lcurr, mI', ...)|
}
{ |conf c (E[newRef I l t]) --> conf c' (E[return (LIORefTCB I l a)])| }
{ |fresh a| }

\and

\inferrule[readRef-|I|]
{ |c = (lcurr, mI, ...)|
}
{ |conf c (E[readRef I (LIORefTCB I l a)]) --> conf c (E[unlabel mI(a)])| }


\and
\inferrule[writeRef-|I|]
{ |c = (lcurr, mI, ...)|\\
  |lcurr canFlowTo l ~>* true|\\
  |mI' = mI[a mapsto LabeledTCB l t]|\\
  |c' = (lcurr, mI', ...)|
}
{ |conf c (E[writeRef I (LIORefTCB I l a) t]) --> conf c' (E[return ()])| }


\and

\inferrule[labelOf-|I|]
{ }
{ |Ep[labelOfR I (LIORefTCB I l a)]) --> Ep[l]| }
\end{mathpar}
\caption{Semantics for flow-insensitive references\label{fig:sos:refs}.}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5

\begin{figure}[h!]
\small
\begin{mathpar}
\inferrule
{ |conf c t --> conf c' t'| }
{ |conf c (E[t]) --> conf c' (E[t'])| }
\and
\inferrule
{ |Ep[t] ~> Ep[t']| }
{ |conf c (Ep[t]) --> conf c (Ep[t'])| }
\and
\inferrule
{ |t ~> t'| }
{ |Ep[t] ~> Ep[t']| }
\end{mathpar}
\caption{Evaluation relations \hl{ Maybe useful somewhere; appendix? } }
\end{figure}


\hl{
Maybe useful somewhere else:
The design constraints imposed by the library approach has led to a
novel point in the design space of language-level IFC systems---when
compared to more traditional IFC systems---that incorporates ideas
from previous IFC operating systems.
}
