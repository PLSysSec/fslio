\section{Flow-sensitivity extensions}
\label{sec:flow-sensitive}

\concept{a more-LIO focused example for why FS}
Unfortunately the flow-insensitive references described in the previous section
are somewhat inflexible.
%
Consider, for example, an application that uses a reference as a log.
%
Since the log may contain sensitive information, it is important that the
reference be labeled.
%
Equally important is to be able to read the log at any point in the program to,
for instance, save it to a file.
%
While labeling the reference with the maximum element in the label lattice
$\top$ would always allow writes to the log, and |toLabeled| can be used to
write the log to a file, this is unsatisfactory: it assumes the existence of a
maximum element, which in practical IFC systems such as Hails~\tocite{}, does
not exist.
%
Moreover, it almost always over-approximates the sensitivity of the
log---suppose that the computation never reads sensitive data, yet wishes to
read the log content to, e.g., format it: it needs to taint itself to $\top$!
%
It is clear that even in the case of simple scenarios, having references with
mutable labels that vary according to the sensitive of what is stored in the
reference is useful.

\concept{naive approach doesn't work}
However, naively implementing flow-sensitive references can effectively
introduce the implicit problem of other language-based system to LIO.
%
Suppose that we allow for the label of a reference to simply be raised to the
current label at the time a |writeRef space| is performed.
%
So, for example, if the label of our log reference is |low| and the computation
has read sensitive data such that the current label is |H|, now writing to the
log raises the label of the reference to |H|.
%
While this approach was clearly shown to be unsafe, due to implicit-flows, in
language-based systems~\tocite{}, LIO eliminates the implicit-flows problem by
construction and thus raises the question: \emph{is this approach safe in LIO?}
%
Unfortunately, the answer to this question is \emph{no}; consider the code
in Figure~\ref{fig:fs-attack}, below:
%
\begin{figure}[h!]
\small
\begin{code}
leakRef :: LIORefTCB space Bool -> LIO Bool
leakRef href = do
  tmp   <- newRef space low ()
  toLabeled high $ do  h <- readRef space href
                       when h (writeRef space tmp ())
  return (labelOfR tmp == high)
\end{code}
\caption{Attack in LIO with naive flow-sensitive reference extension. We ommit
subscripts on reference terminals for clarity.  \label{fig:fs-attack}}
\end{figure}

\concept{can leak into ref label}
\noindent
%
Here, |leakRef| can be used to leak the value stored in a |high| reference
|href|, while keeping the current label |low|, by leveraging the new
implicit-flow channel: the label of references.
%
Concretely, in |leakRef| we create a public reference |tmp| and withing the
|toLabeled| block, which is used to ensure that the current label remains
|low|, the label of this reference is changed to |H| if the secret stored in
|href| is |true|, and left intact (|L|) if the secret is |false|.
%
Then, simply inspecting the label of the reference reveals the value stored in
|href|!
%
We note that the use of |labelOfR space| is not fundamental to this attack; in
Appendix~\ref{sec:app:fs-attack2} we show an alternative version of |leakRef|
that does not rely on label inspection.




This problem can be addressed in several ways. Prior work proposed the
\emph{no-sensitive-upgrade} strategy~\citep{?} and the
\emph{permissive-upgrade} strategy~\citep{?}. The no-sensitive-upgrade
check forbids assignment to a public reference in a secret context. In
contrast, the permissive-upgrade check allows the assignment but marks
it as a partial leak; if there is a subsequent conditional branch on
partially leaked data, the program stops.  We adapt the
permissive-upgrade idea to our floating-label model, which results in
a slightly more permissive enforcement that allows the conditional
branch.

In order to express our flow-sensitive enforcement, we extend the
formalization of |LIO| to include flow-sensitive LIORefs with an
|upgrade| operation. Figure~\ref{fig:fs-exts-syntax} introduces the
syntax for values, terms and types that we require in order to account
for both flow-sensitive and flow-insensitive references.

The expression |m1 merge m2| merges the two stores, using elements
from |m1| to override those of |m2|.

% Figure~\ref{fig:fs-exts-semantics} introduces the semantics for LIORef
% operations. Rule $\textsc{NewRef}$ creates a new LIORef with a given
% initial label and value, adding it to the mutable reference store
% $\RTS$. The following rules come in two versions, one for
% flow-insensitive variables and another one for flow-sensitive ones,
% marked as $\textsc{FI}$ and $\textsc{FS}$ respectively. Rules
% $\textsc{ReadRef-FI}$, $\textsc{WriteRef-FI}$ and
% $\textsc{LabelOf-FI}$ are exactly like in previous versions of the
% library. In rule $\textsc{ReadRef-FS}$, in addition to the usual
% tainting of the current label $\env.\lbl$, we have a taint on
% $\env.\fel$, which is used to keep track of the taint caused by
% flow-sensitive variables within |toLabeled| blocks. Rule
% $\textsc{WriteRef-FS}$ causes the label in the flow-sensitive
% reference to be replaced by the current label, allowing operations
% that would otherwise trigger a security violation exception on a
% flow-insensitive variable. Rule $\textsc{LabelOf-FS}$ works by
% tainting the current label with the label of the reference being
% inspected, before returning this label.

%
% ReadRef and LabelOf rules that propagate the taint outside toLabeled
%
% \inferrule{l\flows\env.\clr \\ \env' = \env[\lbl\mapsto \env.\lbl \lub l] \\ \env'' = \neg u ? \env'[\fel\mapsto \env'.\lbl] : \env' \\  \Lb{l}{u}{v} = \RTS(x)}
% {\defRTS{E[\readRefFS{(\LIORefRTS{l}{x})}]} \lto \wEnvRTS{\env''}{\RTS}{E[\returnLIO{v}]}}[\textsc{ReadRef-FS}]
% \and
% \inferrule{l \flows \env.\clr \and \Lb{l}{u}{\_} = \RTS(x) \\ \env' = \env[\lbl\mapsto\env.\lbl \lub l] \and \env''= \neg u ? \env'[\fel\mapsto\env'.\lbl] : \env'}
% {\defRTS{E[\labelOfFS{(\LIORefRTS{l}{x})}]} \lto \wEnvRTS{\env''}{\RTS}{r}{E[\returnLIO{l}]}}[\textsc{LabelOf-FS}]


\begin{figure}[!ht] % semantics
\small
\begin{code}
v    ::= cdots  | LIORefTCB S t
t    ::= cdots  | upgradeR t t
Ep   ::= cdots  | upgradeR Ep t | upgradeR v Ep
\end{code}

\begin{mathpar}
\inferrule[newRef-|S|]
{ |c = (lcurr, mI, mS)|\\
  |lcurr canFlowTo l ~> true|\\
  |mS' = mS[a mapsto LabeledTCB lcurr (LabeledTCB l t)]|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[newRef S l t]) --> conf c' (E[return (LIORefTCB S a)])| }
{ |fresh a| }

\and

\inferrule[readRef-|S|]
{ |c = (lcurr, mI, mS)| \\
  |mS(a) = LabeledTCB l (LabeledTCB l' t)|\\
  |l lub l' ~> l''|
}
{ |conf c (E[readRef S (LIORefTCB S a)]) --> conf c (E[unlabel (LabeledTCB l'' t)])| }

\and

\inferrule[writeRef-|S|]
{ |c = (lcurr, mI mS)|\\
  |mS(a) = LabeledTCB l (LabeledTCB l' t)| \\
  |lcurr canFlowTo l ~> true|\\
  |mS' = mS[a mapsto LabeledTCB l (LabeledTCB l' t)]|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[writeRef S (LIORefTCB S a) t]) --> conf c' (E[return ()])| }

\and

\inferrule[labelOf-|S|]
{ |c = (lcurr, mI, mS)|\\
  |mS(a) = LabeledTCB l (LabeledTCB l' t)|
}
{ |conf c (E[labelOfR S (LIORefTCB S a)]) --> conf c (E[unlabel (LabeledTCB l l')])|}

\and

\inferrule[upgradeRef]
{ |c = (lcurr, mI, mS)|\\
  |mS(a) = LabeledTCB l' v|\\
  |lcurr canFlowTo l' ~> true| \\
  |conf c (upgrade v l) ==> conf c (LIOTCB v')|\\
  |mS' = mS [ a mapsto LabeledTCB l' v']|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[upgradeR (LIORefTCB S a) l]) --> conf c' (E[return ()])| }
\end{mathpar}
\caption{\liofs{}: \lio{} with flow-sensitive references.\label{fig:fs-exts-semantics}}
\end{figure}

%
% ToLabeled rule that propagates FS taints
%
% \inferrule{\env.\lbl \flows l \flows \env.\clr \\ \eEnvRTS{\env}{\RTS}{r'}{t}\lto^*\wEnvRTS{\env'}{r''}{\RTS'}{\lioValp{t'}} \\ \env'' = \env[\lbl\mapsto\env.\lbl \lub \env'.\fel, \fel\mapsto\env'.\fel]}
% {\defRTS{E[\toLabeled{l}{t}]} \lto \\ \wEnvRTS{\env''}{\RTS'}{r}{E[\returnLIO{(\Lb{l}{\bot}{t'})}]}}[\textsc{toLabeled}]


\begin{figure}[!ht] % semantics
\vspace*{-5pt}
\begin{code}
v    ::= cdots  | set (v, ...) | nil
t    ::= cdots  | set (t, ...) | withRefs t t | toLabeled' t t t
tau  ::= cdots  | set (tau, ...)
     
Ep   ::= cdots  | set (Ep, t, ...) | set(v, Ep, t, ...) | withRefs Ep t 
                | toLabeled' Ep t t | toLabeled' v Ep t

addrs (nil)                                       @= emptyset
addrs (set(LIORefTCB S a1, LIORefTCB S a2, ...))  @= {a1, a2, ...}
\end{code}
\begin{mathpar}
\inferrule[withRefs]
{|c = (lcurr, mI, mS)|\\
 |mS' = {a mapsto mS(a) inlinesep a element dom mS and addrs(v) }|\\
 |conf (lcurr, mI, mS') t ==> conf (lcurr', mI', mS'') (LIOTCB t')|\\
 |c''' = (lcurr', mI', mS'' merge mS)|
}
{|conf c (E[withRefs v t]) --> conf c'' (E[return t']|}
\and
%%XXX: REMOVE THIS:
\inferrule[toLabeled']
{|c = (lcurr, mI, mS)|\\
 |lcurr canFlowTo l ~> true|\\
 |mS' = {a mapsto mS(a) inlinesep a element dom mS and addrs(v) }|\\
 |conf (lcurr, mI, mS') t ==> conf (lcurr', mI', mS'') (LIOTCB t')|\\
 |lcurr' canFlowTo l ~> true|\\
 |c''' = (lcurr, mI', mS'' merge mS)|
}
{|conf c (E[toLabeled' l v t]) --> conf c'' (E[label l t']|}
\end{mathpar}
\begin{code}
toLabeled' l v t  @= withRefs v (toLabeled l t) 
                  == toLabeled l (withRefs v t)
\end{code}
\caption{Semantics for |toLabeled|.\label{fig:toLabeled-semantics}}
\end{figure}
\hl{We should note somewhere that trying to access a non-existant ref results
in program getting stuck}

\begin{figure}
\small
\begin{mathpar}
\inferrule[upgradeStore]
{|c = (lcurr, mI, mS)|\\
 |mS = {a1 mapsto v1, ..., a_n mapsto v_n}|\\
 |t = upgradeR (LIORefTCB S a1) lcurr >> ... >> upgradeR (LIORefTCB S a_n) lcurr|
}
{|conf c (E[upgradeM]) --> conf c (E[t])|}
\end{mathpar}
\caption{Semantics for |upgradeM|}
\end{figure}

\begin{figure}
\vspace*{-5pt}
\begin{code}
toLabeledWith :: Label l =>
      l -> a -> (LIORef FS l a -> LIO l b)
  ->  LIO l (Labeled FS l b)
toLabeledWith l def f =
    do  y    <-  newLIORef l def
        upgrade y l -- set the upgraded flag
        ret  <-  toLabeled [y] (f y)
        destroyLIORef y
        return ret
\end{code}
\caption{Definition of |toLabeledWith|.\label{fig:toLabeledWith-semantics}}
\vspace*{-5pt}
\end{figure}

\begin{figure}
\vspace*{-5pt}
\begin{mathpar}
\inferrule[unlabel-AU]
{ |c = (lcurr, mI, mS)|\\
  |lcurr lub l ~> lcurr'|\\
  |c' = (lcurr', mI, mS)|
}
{
|conf c (E[unlabel (LabeledTCB l t)]) --> conf c' (E[upgradeM >> return t])|
}
\end{mathpar}
\caption{Semantics for |unlabel| with automatic upgrades.\label{fig:unlabel-autoupgrade}}
\vspace*{-5pt}
\end{figure}

% Figure~\ref{fig:toLabeled-semantics} shows the reduction rule for
% |toLabeled| operations. In this rule, we see that the $\env.\fel$
% label is used to taint the current label after the |toLabeled|
% operation is complete. This allows any partially-leaked information
% (due to flow-sensitive references) to be taken into account in future
% label checks.

\begin{definition}
We define the equivalence relation oblivious to flow-sensitive reference
implemnetation as:
\begin{itemize}
\item |LIORefTCB S t &=  LIORefTCB S t'| for any |t|, |t'|.
\item |t &=  t'| iff |t = t'|.
\item |LIOTCB t &=  LIOTCB t'| iff |t &=  t'|.
\item |LabeledTCB l t &= LabeledTCB l t'| iff |t &=  t'| and |l &=  l'|.
\item etc.
\end{itemize}
\end{definition}

\begin{theorem}[Equivalence]
For all |t, v| in \lio{} and |t', v'| in \liofs{},
and |v &= v'|, it must be that
%
|conf (lcurr,mI) t  ==> conf (lcurr',...) diverge| $\Leftrightarrow$
|conf (lcurr,mI,emptyset) t' ==> conf (lcurr',...) diverge| and 
%
|conf (lcurr,mI) t  ==> conf (lcurr',...) v| $\Leftrightarrow$
|conf (lcurr,mI,emptyset) t' ==> conf (lcurr',...) v'|.
\end{theorem}
