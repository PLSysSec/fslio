\section{Flow-sensitivity extensions}
\label{sec:flow-sensitive}

Previous versions of |LIO| support mutable references (LIORefs) with a
fixed label, which is preserved throughout the computation. These
references are known as \emph{flow-insensitive}. In this work, we
extend |LIO| to include \emph{flow-sensitive} references,
i.e. references which can store values with different labels over the
course of the computation. Unlike their flow-insensitive counterparts,
the label associated with such a reference is mutable, and will vary
according to the sensitivity of what is stored in the
reference. Writing a secret value to a public reference in this
context will cause the reference to be relabelled as secret, instead
of halting the program.

Flow-sensitive references allow the enforcement mechanism to accept a
greater number of secure programs. Nevertheless,
Russo~and~Sabelfeld~\citep{?} show that a naive implementation of this
idea in a dynamic enforcement introduces a security leak. We
illustrate this attack in the context of |LIO| in
Figure~\ref{fig:fs-attack}. In this function, we assume that we have a
version of |LIO| where |LIORef|s are flow-sensitive, so the
|writeLIORef| operations in the conditionals can raise the label of
the reference they assign to, if the current label is $H$. The
function takes both a |public| and a |secret| reference as parameters,
which contain either 1 or 0. Then, the function creates a public
reference |temp| with initial value 0, and assigns 1 to |public|.
Note that, if the value of |secret| is 1, the first |writeLIORef| is
executed, but this causes |temp| to be 1, which prevents the second
|writeLIORef| from executing. Thus, |public| is untouched and it will
contain the value of |secret|. If the value of |secret| is 0, the
first |writeLIORef| is not executed, but the second one is, causing
|public| to be assigned the value 0. Since |temp| has not been
assigned in a secret context, its label remains $L$, and so does the
label of |public|. In either case, the final value of |public| matches
the value in |secret|, so one bit of information has been leaked
through this attack, without using the termination channel.
% maybe say that the key part of the attack is the fact that temp
% has different labels in different runs of the progam ???

\begin{figure}[!ht]
\vspace*{-5pt}
\begin{code}
attack public secret = 
  do  temp    <- newLIORef L 0
      writeLIORef public 1
      toLabeled H $ do
        x <- readLIORef secret
        when (x == 1) (writeLIORef temp 1)
      toLabeled H $ do
        t <- readLIORef temp
        when (t /= 1) (writeLIORef public 0)
\end{code}
\caption{Potential flow-sensitivity attack in |LIO|.\label{fig:fs-attack}}
\vspace*{-5pt}
\end{figure}

This problem can be addressed in several ways. Prior work proposed the
\emph{no-sensitive-upgrade} strategy~\citep{?} and the
\emph{permissive-upgrade} strategy~\citep{?}. The no-sensitive-upgrade
check forbids assignment to a public reference in a secret context. In
contrast, the permissive-upgrade check allows the assignment but marks
it as a partial leak; if there is a subsequent conditional branch on
partially leaked data, the program stops. We adapt the
permissive-upgrade idea to our floating-label model, which results in
a slightly more permissive enforcement that allows the conditional
branch.

We extend the formalization of |LIO| to include both flow-insensitive
and flow-sensitive LIORefs. Figure~\ref{fig:fs-exts-syntax} introduces
the syntax for values, terms and types that we require in order to
account for both flow-sensitive and flow-insensitive references.

\begin{figure}[!ht] % syntax
\centering
\begin{code}
v    ::= cdots  | LIORefTCB I t| LIORefTCB S v t
t    ::= cdots  | newRef s t t | writeRef s t t 
                | readRef s t | upgrade t t
                | labelOfR s t
tau  ::= cdots  | LIORef s tau


Ep   ::= cdots  | newRef s Ep t | writeRef s Ep t 
                | readRef s Ep | upgrade Ep t | upgrade v Ep
                | labelOfR s Ep
\end{code}
\caption{Formal syntax for values, terms, and types,
where |s  ::=  S inlinesep I|.\label{fig:fs-exts-syntax}}
\vspace*{-5pt}
\end{figure} 

The expression |m1 merge m2| merges the two stores, using elements
from |m1| to override those of |m2|.

% Figure~\ref{fig:fs-exts-semantics} introduces the semantics for LIORef
% operations. Rule $\textsc{NewRef}$ creates a new LIORef with a given
% initial label and value, adding it to the mutable reference store
% $\RTS$. The following rules come in two versions, one for
% flow-insensitive variables and another one for flow-sensitive ones,
% marked as $\textsc{FI}$ and $\textsc{FS}$ respectively. Rules
% $\textsc{ReadRef-FI}$, $\textsc{WriteRef-FI}$ and
% $\textsc{LabelOf-FI}$ are exactly like in previous versions of the
% library. In rule $\textsc{ReadRef-FS}$, in addition to the usual
% tainting of the current label $\env.\lbl$, we have a taint on
% $\env.\fel$, which is used to keep track of the taint caused by
% flow-sensitive variables within |toLabeled| blocks. Rule
% $\textsc{WriteRef-FS}$ causes the label in the flow-sensitive
% reference to be replaced by the current label, allowing operations
% that would otherwise trigger a security violation exception on a
% flow-insensitive variable. Rule $\textsc{LabelOf-FS}$ works by
% tainting the current label with the label of the reference being
% inspected, before returning this label.

%
% ReadRef and LabelOf rules that propagate the taint outside toLabeled
%
% \inferrule{l\flows\env.\clr \\ \env' = \env[\lbl\mapsto \env.\lbl \lub l] \\ \env'' = \neg u ? \env'[\fel\mapsto \env'.\lbl] : \env' \\  \Lb{l}{u}{v} = \RTS(x)}
% {\defRTS{E[\readRefFS{(\LIORefRTS{l}{x})}]} \lto \wEnvRTS{\env''}{\RTS}{E[\returnLIO{v}]}}[\textsc{ReadRef-FS}]
% \and
% \inferrule{l \flows \env.\clr \and \Lb{l}{u}{\_} = \RTS(x) \\ \env' = \env[\lbl\mapsto\env.\lbl \lub l] \and \env''= \neg u ? \env'[\fel\mapsto\env'.\lbl] : \env'}
% {\defRTS{E[\labelOfFS{(\LIORefRTS{l}{x})}]} \lto \wEnvRTS{\env''}{\RTS}{r}{E[\returnLIO{l}]}}[\textsc{LabelOf-FS}]


\begin{figure}[!ht] % semantics
\small
\begin{mathpar}
\inferrule[newRef-|S|]
{ |c = (lcurr, mI, mS)|\\
  |lcurr canFlowTo l ~>* true|\\
  |mS' = mS[a mapsto (lcurr, LabeledTCB l t)]|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[newRef S l t]) --> conf c' (E[return (LIORefTCB S a)])| }
{ |fresh a| }


\and

\inferrule[readRef-|S|]
{ |c = (lcurr, mI, mS)| \\
  |mS(a) = (l, LabeledTCB l' t)|\\
  |l lub l' ~>* l''|
}
{ |conf c (E[readRef S (LIORefTCB S a)]) --> conf c (E[unlabel (LabeledTCB l'' t)])| }


\and
\inferrule[writeRef-|S|]
{ |c = (lcurr, mI mS)|\\
  |mS(a) = (l, LabeledTCB l' t)| \\
  |lcurr canFlowTo l ~>* true|\\
  |lcurr canFlowTo l' ~>* true|\\
  |mS' = mS[a mapsto (l, LabeledTCB l' t)]|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[writeRef S (LIORefTCB S a) t]) --> conf c' (E[return ()])| }


% \and

% \inferrule[labelOf]
% { |c = (lcurr, mI, mS)| \\
%   |(lf, LabeledTCB l x) = m_alpha (a)| }
% { |conf c (E[labelOfR alpha (LIORefTCB alpha a) t]) --> conf c (E[return l])| }

%%\inferrule{}
%%{\defRTS{E[\labelOfFI{(\LIORefRTS{l}{x})}]} \lto \wEnvRTS{\env}{\RTS}{r}{E[\returnLIO{l}]}}[\textsc{LabelOf-FI}]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Flow sensitive references:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\inferrule{l\flows\env.\clr \\ \env' = \env[\lbl\mapsto \env.\lbl \lub l] \and \RTS'=\RTS\uparrow^{\env'.\lbl} r \\  \Lb{l}{u}{v} = \RTS(x)}
%%{\defRTS{E[\readRef{(\LIORefRTS{l}{x})}]} \lto \wEnvRTS{\env'}{\RTS'}{r}{E[\returnLIO{v}]}}[\textsc{ReadRef}]

% \and

% \inferrule[writeRef-S]
% { |c = (lcurr, m)|\\
%   | (lf, LabeledTCB l t) = m(a)|\\
%   | l lub lcurr ~>* l'|\\
%   |c' = (lcurr, m[a mapsto (lf, LabeledTCB l' t')])|
% }
% { |conf c (E[writeRef S (LIORefTCB S l a) t']) --> conf c' (E[return ()])| }

%%\inferrule{l \flows \env.\lbl \and \RTS' = \RTS[ x \mapsto \Lb{\env.\lbl}{\bot}{v} ] \and x \in r}
%%{\defRTS{E[\writeRefFS{(\LIORefRTS{l}{x})}{v}]} \lto \wEnvRTS{\env}{\RTS}{r}{E[\returnLIO{()}]}}[\textsc{WriteRef-FS}]

\and

\inferrule[labelOf-|S|]
{ |c = (lcurr, mI, mS)|\\
  |mS(a) = (l, LabeledTCB l' t)|
}
{ |conf c (E[labelOfR S (LIORefTCB S a)]) --> conf c (E[unlabel (LabeledTCB f l')])|}

%%\inferrule{l \flows \env.\clr \and \Lb{l}{u}{\_} = \RTS(x) \\ \env' = \env[\lbl\mapsto\env.\lbl \lub l] \and \RTS'=\RTS\uparrow^{\env'.\lbl} r }
%%{\defRTS{E[\labelOfFS{(\LIORefRTS{l}{x})}]} \lto \wEnvRTS{\env'}{\RTS'}{r}{E[\returnLIO{l}]}}[\textsc{LabelOf-FS}]


\and

\inferrule[upgradeRef]
{ |c = (lcurr, mI, mS)|\\
  |mS(a) = (l', v)|\\
  |lcurr canFlowTo l' ~>* true| \\
  |conf c (upgrade v l) ==> conf c (LIOTCB v')|\\
  |mS' = mS [ a mapsto (l',v') ]|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[upgradeR (LIORefTCB S a) l]) --> conf c' (E[return ()])| }

%%-deian-\inferrule{\env.\lbl\flows l \and l\flows l' \and \RTS'=\RTS\uparrow^{l'} \{x\}}
%%-deian-{\defRTS{E[\upgrade{(\LIORef{l}{x})}{l'}]} \lto \wEnvRTS{\env}{\RTS'}{r}{E[\returnLIO{()}]}}[\textsc{Upgrade}]


\end{mathpar}
\caption{Semantics for references.\label{fig:fs-exts-semantics}}
\end{figure}

\begin{figure}
\begin{code}
newtype LIORefTCB S t = LIORefTCB S (LIORefTCB I t)

wrap :: LIORef I t -> LIORef S t
wrap r @= LIORefTCB S r

unwrap :: LIORef S t -> LIORef I t
unwrap (LIORefTCB S r) @= r

newRef S l t @= do
  lcurr  <- getLabel
  v      <- label l t
  r      <- newRef I lcurr v
  return (wrap r)


readRef S r @= readRef I (unwrap r) >>= unlabel


writeRef S r t @= let  r'  = unwrap r
                       l   = labelOf r' in do
  lcurr <- getLabel
  when (lcurr canFlowTo l) $ toLabeled l $ do
     v   <- readRef I r'
     v'  <- label (labelOf v) t
     writeRef r' v'


labelOfR S r @= readRef I (unwrap r) >>= return . labelOf

upgradeR r l @= let  r'  = unwrap r
                     l'  = labelOf r' in do
  lcurr <- getLabel
  when (lcurr canFlowTo l') $ toLabeled l' $ do
     v   <- readRef I r'
     v'  <- upgrade v l
     writeRef r' v'

\end{code}
\caption{Implementation for flow-sensitive references.\label{fig:fs-exts-semantics-impl}}
\end{figure}

%
% ToLabeled rule that propagates FS taints
%
% \inferrule{\env.\lbl \flows l \flows \env.\clr \\ \eEnvRTS{\env}{\RTS}{r'}{t}\lto^*\wEnvRTS{\env'}{r''}{\RTS'}{\lioValp{t'}} \\ \env'' = \env[\lbl\mapsto\env.\lbl \lub \env'.\fel, \fel\mapsto\env'.\fel]}
% {\defRTS{E[\toLabeled{l}{t}]} \lto \\ \wEnvRTS{\env''}{\RTS'}{r}{E[\returnLIO{(\Lb{l}{\bot}{t'})}]}}[\textsc{toLabeled}]


\begin{figure}[!ht] % semantics
\vspace*{-5pt}
\begin{code}
v    ::= cdots  | set (v, ...) | nil
t    ::= cdots  | set (t, ...) | toLabeled' t t t
tau  ::= cdots  | set (tau, ...)
     
Ep   ::= cdots  | set (Ep, t, ...) | set(v, Ep, t, ...)
                | toLabeled' Ep t t | toLabeled' v Ep t

addrs (nil)                                       @= emptyset
addrs (set(LIORefTCB S a1, LIORefTCB S a2, ...))  @= {a1, a2, ...}
\end{code}
\begin{mathpar}
\inferrule[toLabeled]
{|c = (lcurr, mI, mS)|\\
 |lcurr canFlowTo l|\\
 |mS' = {a mapsto mS(a) inlinesep a element dom mS and addrs(v) }|\\
 |conf (lcurr, mI, mS') t ==> conf (lcurr', mI', mS'') (LIOTCB t')|\\
 |lcurr' canFlowTo l|\\
 |c''' = (lcurr, mI', mS'' merge mS)|
}
{|conf c (E[toLabeled' l v t]) --> conf c''' (E[label l t']|}
%%\inferrule{\env.\lbl \flows l \flows \env.\clr \and r' \subseteq r \\ \wEnvRTS{\env}{\RTS}{r'}{t}\lto^*\wEnvRTS{\env'}{r''}{\RTS'}{\lioValp{t'}} }
%%{\defRTS{E[\toLabeled{l\ r'}{t}]} \lto \\ \wEnvRTS{\env}{\RTS'}{r\cup r''}{E[\returnLIO{(\Lb{l}{\bot}{t'})}]}}[\textsc{toLabeled}]
\end{mathpar}
\caption{Semantics for |toLabeled|.\label{fig:toLabeled-semantics}}
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule[upgradeStore]
{|c = (lcurr, mI, mS)|\\
 |refs(mS) = {a1, ..., a_n}|\\
 |t = upgradeR (LIORefTCB S a1) lcurr >> ... >> upgradeR (LIORefTCB S a_n) lcurr|
}
{|conf c (E[upgradeM]) --> conf c (E[t])|}
\end{mathpar}
\caption{Semantics for |upgradeM|}
\end{figure}

\begin{figure}
\vspace*{-5pt}
\begin{code}
toLabeledWith :: Label l =>
      l -> a -> (LIORef FS l a -> LIO l b)
  ->  LIO l (Labeled FS l b)
toLabeledWith l def f =
    do  y    <-  newLIORef l def
        upgrade y l -- set the upgraded flag
        ret  <-  toLabeled [y] (f y)
        destroyLIORef y
        return ret
\end{code}
\caption{Definition of |toLabeledWith|.\label{fig:toLabeledWith-semantics}}
\vspace*{-5pt}
\end{figure}

\begin{figure}
\vspace*{-5pt}
\begin{mathpar}
\inferrule[unlabel-AU]
{ |c = (lcurr, ...)|\\
  |lcurr lub l ~> lcurr'|\\
  |c' = (lcurr', ...)|
}
{
|conf c (E[unlabel (LabeledTCB l t)]) --> conf c' (E[upgradeM >> return t])|
}
\end{mathpar}
\caption{Semantics for |unlabel| with automatic upgrades.\label{fig:unlabel-autoupgrade}}
\vspace*{-5pt}
\end{figure}

% Figure~\ref{fig:toLabeled-semantics} shows the reduction rule for
% |toLabeled| operations. In this rule, we see that the $\env.\fel$
% label is used to taint the current label after the |toLabeled|
% operation is complete. This allows any partially-leaked information
% (due to flow-sensitive references) to be taken into account in future
% label checks.
