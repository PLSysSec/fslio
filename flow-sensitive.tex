\section{Flow-sensitivity extensions}
\label{sec:flow-sensitive}

\concept{a more-LIO focused example for why FS}
Unfortunately the flow-insensitive references described in the previous section
are somewhat inflexible.
%
Consider, for example, an application that uses a reference as a log.
%
Since the log may contain sensitive information, it is important that the
reference be labeled.
%
Equally important is to be able to read the log at any point in the program to,
for instance, save it to a file.
%
While labeling the reference with the maximum element in the label lattice
$\top$ would always allow writes to the log, and |toLabeled| can be used to
write the log to a file, this is unsatisfactory: it assumes the existence of a
maximum element, which in practical IFC systems such as Hails~\tocite{}, does
not exist.
%
Moreover, it almost always over-approximates the sensitivity of the
log---suppose that the computation never reads sensitive data, yet wishes to
read the log content to, e.g., format it: it needs to taint itself to $\top$!
%
It is clear that even in the case of simple scenarios, having references with
mutable labels that vary according to the sensitive of what is stored in the
reference is useful.

\concept{naive approach doesn't work}
However, naively implementing flow-sensitive references can effectively
introduce the implicit problem of other language-based system to LIO.
%
Suppose that we allow for the label of a reference to simply be raised to the
current label at the time a |writeRef space| is performed.
%
So, for example, if the label of our log reference is |low| and the computation
has read sensitive data such that the current label is |H|, now writing to the
log raises the label of the reference to |H|.
%
While this approach was clearly shown to be unsafe, due to implicit-flows, in
language-based systems~\tocite{}, LIO eliminates the implicit-flows problem by
construction and thus raises the question: \emph{is this approach safe in LIO?}
%
Unfortunately, the answer to this question is \emph{no}; consider the code
in Figure~\ref{fig:fs-attack}, below:
%
\begin{figure}[h!]
\small
\begin{code}
leakRef :: LIORefTCB space Bool -> LIO Bool
leakRef href = do
  tmp   <- newRef space low ()
  toLabeled high $ do  h <- readRef space href
                       when h (writeRef space tmp ())
  return (labelOfR space tmp == high)
\end{code}
\cut{$}
\caption{Attack in LIO with naive flow-sensitive reference extension. We ommit
subscripts on reference terminals for clarity.  \label{fig:fs-attack}}
\end{figure}

\concept{can leak into ref label}
\noindent
%
Here, |leakRef| can be used to leak the value stored in a |high| reference
|href|, while keeping the current label |low|, by leveraging the new
implicit-flow channel: the label of references.
%
Concretely, in |leakRef| we create a public reference |tmp| and withing the
|toLabeled| block, which is used to ensure that the current label remains
|low|, the label of this reference is changed to |H| if the secret stored in
|href| is |true|, and left intact (|L|) if the secret is |false|.
%
Then, simply inspecting the label of the reference reveals the value stored in
|href|!
%
We note that the use of |labelOfR space| is not fundamental to this attack; in
Appendix~\ref{sec:app:fs-attack2} we show an alternative version of |leakRef|
that does not rely on label inspection.

\concept{KEY INSIGHT:}
Fundamentally, the label protecting the \emph{label} of an object (e.g.,
labeled values and references) is the current label |lcurr| at the time of
creation.
%
Hence, to modify the label of the object within some context (e.g., |toLabeled|
block) wherein the current label is |lcurr'| it must be that the |lcurr'
canFlowTo lcurr|, i.e., we must be able to write data at sensitivity level
|lcurr'| into an entity (the label) labeled |lcurr|.
%
This is especially important if we can restore the current label from |lcurr'|
to |lcurr| and subsequently observe the leak within the program itself.
%
In the case where the label of the object is immutable, as is the case for
labeled values and flow-insensitive references, this is not a concern: even if
the current label is raised to |lcurr'| and then restored to |lcurr| we do not
learn any information more sensitive than |lcurr| (the label of the label at
the time of creation) by inspecting the label: the label has not changed!
%

\concept{\liofs{}}
Thus, to extend LIO with flow-sensitive reference we must account for the label
on the label of the reference at the time of creation, |lcurr|.
%
(This label is, however, immutable.)
%
In turn, when changing the label of the reference, we must ensure that no data
from the context at the time of the change, whose label is |lcurr'|, is leaked
into the label of the reference by ensuring that |lcurr' canFlowTo lcurr|,
i.e., we can write data labeled |lcurr'| into the label labeled |lcurr|.
%
Formally, we extend the \lio{} syntax as shown in Figure~\ref{fig:sos:refs},
with |s=S|, and Figure~\ref{fig:sos:fs};
%
the reduction rules for this extended calculus, called \liofs{}, are also
given in Figure~\ref{fig:sos:fs}.

\concept{\liofs{} semantics}
When creating a flow-sensitive reference, |newRef S l t| creates a labeled
value that guards |t| with label |l| (|LabeledTCB l t|).
%
However, since we wish to to allow programmers to modify the label |l| of the
reference, we additionally store the label on |l|, i.e., |lcurr|, by simply
labeling the already-guarded term, as as shown in rule~\ruleref{newRef-|S|}.
%
|newRef S| returns a |LIORefTCB S a| which simply encapsulates the fresh
reference address where the doubly-labeled term is stored.
%
Note that this values from the flow-insensitive case in not encapsulating the
label of the reference.
%
This is precisely because the label of a flow-sensitive reference is not
mutable and must be looked up in the store.
%
As given by rule~\ruleref{labelOf-|S|}, |labelOfR S| returns the label of the
reference after raising the current label (with |unlabel|) to account for the
fact that the label of the reference |l'| is a value at sensitivity level |l|,
i.e., we raise the current label to the join of the current label and the label
on the label.
%
The rules for reading and writing to flow-sensitive references are mostly
standard; |readRef S| raise the current label to the label of the reference
(which is above the label on the label) and |writeRef S| ensure that the
current computation can write to the reference.
%
One peculiarity with |writeRef S| is the case when the current label does not
flow to the join of the reference label, i.e., |lcurr canFlowTo l lub l' ~>*
false|, and thus the write should fail.
%
If our program simply gets stuck, the current label does not reflect the fact
that the rule relies, and thus observes, the label on the reference |l'| which
is itself protected by |l|; hence, we provide an explicit rule for this failure
case that first raises the current label (through |unlabel|) and then
divergence (we do not provide a reduction rule for |divergence|).
%
Additionally, we note that |writeRef S| does not modify the label of the reference.
%
This is, in part, because we wish to keep the infer ace between
flow-insensitive and flow-sensitive references as close as possible.
%
Instead, we provide |upgradeR| precisely for this purpose; this primitive is
used to raise the label of the reference.
%
Importantly it ensures that the current computation can modify the label by
checking that the current label flows to the label on the label (|lcurr
canFlowTo l'|).


\begin{figure} % semantics
\small
\begin{code}
v    ::= cdots  | LIORefTCB S t
t    ::= cdots  | upgradeR t t | diverge
Ep   ::= cdots  | upgradeR Ep t | upgradeR v Ep
\end{code}

\begin{mathpar}
\inferrule[newRef-|S|]
{ |c = (lcurr, mI, mS)|\\
  |lcurr canFlowTo l ~> true|\\
  |fresh a|\\
  |mS' = mS[a mapsto LabeledTCB lcurr (LabeledTCB l t)]|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[newRef S l t]) --> conf c' (E[return (LIORefTCB S a)])| }

\and

\inferrule[readRef-|S|]
{ |c = (lcurr, mI, mS)| \\
  |mS(a) = LabeledTCB l (LabeledTCB l' t)|\\
  |l lub l' ~> l''|
}
{ |conf c (E[readRef S (LIORefTCB S a)]) --> conf c (E[unlabel (LabeledTCB l'' t)])| }

\and

\inferrule[writeRef-|S|]
{ |c = (lcurr, mI mS)|\\
  |mS(a) = LabeledTCB l (LabeledTCB l' t)| \\
  |lcurr canFlowTo (l lub l') ~>* true|\\
  |mS' = mS[a mapsto LabeledTCB l (LabeledTCB l' t)]|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[writeRef S (LIORefTCB S a) t]) --> conf c' (E[return ()])| }

\and

\inferrule[writeRef-|S|-fail]
{ |c = (lcurr, mI mS)|\\
  |mS(a) = LabeledTCB l (LabeledTCB l' t)| \\
  |lcurr canFlowTo (l lub l') ~>* false|
}
{ |conf c (E[writeRef S (LIORefTCB S a) t]) --> conf c' (E[unlabel (LabeledTCB l diverge)])| }

\and

\inferrule[labelOf-|S|]
{ |c = (lcurr, mI, mS)|\\
  |mS(a) = LabeledTCB l (LabeledTCB l' t)|
}
{ |conf c (E[labelOfR S (LIORefTCB S a)]) --> conf c (E[unlabel (LabeledTCB l l')])|}

\and

\inferrule[upgradeRef]
{ |c = (lcurr, mI, mS)|\\
  |mS(a) = LabeledTCB l' v|\\
  |lcurr canFlowTo l' ~> true| \\
  |conf c (upgrade v l) ==> conf c (LIOTCB v')|\\
  |mS' = mS [ a mapsto LabeledTCB l' v']|\\
  |c' = (lcurr, mI, mS')|
}
{ |conf c (E[upgradeR (LIORefTCB S a) l]) --> conf c' (E[return ()])| }
\end{mathpar}
\caption{\liofs{}: \lio{} with flow-sensitive references.\label{fig:sos:fs}}
\end{figure}


\subsection{Automatic upgrades}
\label{sec:flow-sensitive:auto}

\begin{figure} % auto-fs
\small
\begin{code}
v    ::= cdots  | set (v, ...) | nil
t    ::= cdots  | set (t, ...) | withRefs t t
tau  ::= cdots  | set (tau, ...)
Ep   ::= cdots  | set (Ep, t, ...) | set(v, Ep, t, ...) | withRefs Ep t 

addrs (nil)                                       @= emptyset
addrs (set(LIORefTCB S a1, LIORefTCB S a2, ...))  @= {a1, a2, ...}
\end{code}
\begin{mathpar}
\inferrule[withRefs]
{|c = (lcurr, mI, mS)|\\
 |mS' = {a mapsto mS(a) inlinesep a element dom mS and (addrs v) }|\\
 |conf (lcurr, mI, mS') t ==> conf (lcurr', mI', mS'') (LIOTCB t')|\\
 |c''' = (lcurr', mI', mS'' merge mS)|
}
{|conf c (E[withRefs v t]) --> conf c'' (E[return t']|}
\and
\inferrule[upgradeStore]
{|c = (lcurr, mI, mS)|\\
 |mS = {a1 mapsto v1, ..., a_n mapsto v_n}|\\
 |ti = upgradeR (LIORefTCB S a_i) l, i = 1, ..., n|
}
{|conf c (E[upgradeM l]) --> conf c (E[t1 >> ... >> t_n])|}
\and
\inferrule[unlabel-au]
{ |c = (lcurr, mI, mS)|\\
  |lcurr' = lcurr lub l|\\
  |conf c (upgradeM lcurr') ==> conf (lcurr, mI, mS') (LIOTCB ())|\\
  |c' = (lcurr', mI, mS')|
}
{
|conf c (E[unlabel (LabeledTCB l t)]) --> conf c' (E[return t])|
}
\end{mathpar}
\caption{\lioafs{}: Extending \liofs{} with auto-upgrades.\label{fig:sos:afs}}
\end{figure}

\concept{upgrade is burdensome}
We can use \liofs{} to implement various applications that rely on
flow-sensitive references, even those that rely on policies such as the
popular no-sensitive upgrades of Austin and Flanagan~\cite{Austin:Flanagan:PLAS09}.
%
(In Section~\ref{sec:related}, we describe the encoding of a policy that is
similar to, but more permissive than, no-sensitive upgrades.)
%
Using \liofs{} we can also safely implement our logging application using a
flow-sensitive reference.
%
Unfortunately, our system (and other like it) requires that we insert
|upgrade|s before we raise the current label, if we wish to write to the
reference in the more-sensitive context.

\concept{auto upgrade}
Inspired by~\citep{Hedin13}, we thus provide an extension to \liofs{} that can
be used to automatically upgrade references.
%
This extension, called \lioafs{}, is given in Figure~\ref{fig:sos:afs}.
%
Intuitively, whenever the current label is about to be raised, we first upgrade
all the references in the |mS| store, with |upgradeM|, in the store and then
raise the current label.
%
Since in our calculus |unlabel| is the only function that raises the current
label, we augment the \rule{unlabel} rule with \rule{unlabel-au} given in
Figure~\ref{fig:sos:afs}.
%
In doing so, this ensures that as the computation progresses it does not
``lose'' write access to its references.
%
Returning to our logging example, with auto-upgrades, the reference used as the
log never needs to be explicitly upgraded and can always be written to---an
interface expected of a log.

\concept{store creep}
Recall, however, that |toLabeled| provides a means for temporarily raising the
current label, allowing thereby allowing us to write programs that do not have
label creep.
%
Unfortunately, with auto-upgrades, when the current label within a |toLabeled|
block is raised, the upgrades of the flow-sensitive references remain even
after the current label is restored.
%
Thus, reading from any flow-sensitive reference after the |toLabeled|
block will raise the current label to, at least, the current label at the end
of the |toLabeled| block (since all references are upgraded).
%
This can be used to carry out a ``poison pill''-like attack~\tocite{breeze}, wherein
the (usually untrusted) computation executing within the |toLabeled| block will
render the outer computation useless by imposing label creep.

\concept{withRefs}
To address this issue, our \lioafs{} calculus further extends \liofs{} with
|withRefs v t| which takes a bag |v| of references and a computation |t|, and
executes |t| in a configuration where the flow-sensitive reference store only
contains the subset of references |v|.
%
A bag is either empty |nil|, or a number of references |set (v,..)|, where each
element in the bag may have a distinct type.
%
Rule \ruleref{withRefs} precisely defines the semantics of this new primitive,
where meta function |addrs| converts a bag of references to a set of their
corresponding addresses, and |merge| is used to merge the stores, giving
preferences to the left-hand-side store.
%
The primitive is mostly standard and provides a programming paradigm similar to
that already present in some mainstream languages (e.g., C++'s \Red{ASK DM}).
%
We lastly remark that by simply wrapping |toLabeled| with |withRefs|, and
thereby restrict the (untrusted) code within the |toLabeled| block from
upgrading arbitrary references, we eliminate the aforementioned attack.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \begin{definition}
%% We define the equivalence relation oblivious to flow-sensitive reference
%% implemnetation as:
%% \begin{itemize}
%% \item |LIORefTCB S t &=  LIORefTCB S t'| for any |t|, |t'|.
%% \item |t &=  t'| iff |t = t'|.
%% \item |LIOTCB t &=  LIOTCB t'| iff |t &=  t'|.
%% \item |LabeledTCB l t &= LabeledTCB l t'| iff |t &=  t'| and |l &=  l'|.
%% \item etc.
%% \end{itemize}
%% \end{definition}
%% 
%% \begin{theorem}[Equivalence]
%% For all |t, v| in \lio{} and |t', v'| in \liofs{},
%% and |v &= v'|, it must be that
%% %
%% |conf (lcurr,mI) t  ==> conf (lcurr',...) diverge| $\Leftrightarrow$
%% |conf (lcurr,mI,emptyset) t' ==> conf (lcurr',...) diverge| and 
%% %
%% |conf (lcurr,mI) t  ==> conf (lcurr',...) v| $\Leftrightarrow$
%% |conf (lcurr,mI,emptyset) t' ==> conf (lcurr',...) v'|.
%% \end{theorem}
