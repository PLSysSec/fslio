
%format true = True
%format false = False
%format unit = "()"

%format /\ = "\land"
%format :- = "\vdash"

%format ttrue = "\mathbf{true}"
%format ffalse = "\mathbf{false}"

%format divisor = "\;|\;"
%format inlinesep = "|"

%format Alice = "\textrm{Alice}"
%format Bob = "\textrm{Bob}"

%format medium = "\textbf{M}"
%format high = "\textbf{H}"
%format low = "\textbf{L}"
%format marked = "\textbf{P}"
%format H = "\textbf{H}"
%format L = "\textbf{L}"

% label operation related:
\newcommand{\flows}{\sqsubseteq}
\newcommand{\lub}{\sqcup}
\newcommand{\glb}{\sqcap}
%format canFlowTo = "\flows"
%format cantFlowTo = "\not\flows"
%format canFlowToStrict = "\sqsubset"
%format canFlowTo_p
%format canFlowTo_Alice
%format lub = "\lub" 
%format glb = "\glb"
%format oplus = "\oplus"

%format l_u

% arrows:
\newcommand{\lto}{\longrightarrow}
%format --> = "\lto"
%format ==> = "\lto^*"
%format .--> = "\overset{"fork(t)"}{\lto}"
%format .-.-> = "\overset{"fork(t')"}{\lto}"
%format ~> = "\lto"
%format ~>* = ~>"^*"


\newcommand{\erase}[2]{\varepsilon_{#1}(#2)}
%format &~> =  ~>"_l"
%format &~>* =  ~>*"_l"
%format &--> = -->"_l"
%format &==> = ==>"_l"
%format (erase (l) (t)) = "\erase{"l"}{"t"}"
%format hole = "\bullet"
%format diverge = "{\Uparrow}"
%format whenDiv = when"_"diverge


\newcommand{\safe}[1]{\varsigma({#1})}
%format (safe (t)) = "\safe{"t"}"

\newcommand{\lequiv}[1]{\approx_{#1}}
%format &~ = "\approx_{"l"}"

% lattice/label related
\newcommand{\lattice}{\ensuremath{\ell}}
%format lattice = "\lattice"
%format lattice_2
%format lattice_3
%format lattice2
%format lattice3

\newcommand{\lcurr}{\ensuremath{l_{\textrm{cur}}}}
%format lcurr = "\lcurr"
%format lcurr'
%format lcurr''
\newcommand{\ccurr}{\ensuremath{c_{\textrm{cur}}}}
%format ccurr = "\ccurr"
%format ccurr'
%format ccurr''

%format l_A
%format l_B
%format l_AB
%format l_c
%format l_d
%format l_o
%format l_e
%format l_f
%format l_Alice
%format l_Bob
%format l1
%format l2
%format l3
%format li = l"_"i
%format li' = l'"_"i

%format e_1
%format e_2

%format M1
%format M2

%format p_Alice
%format p_Bob

%format ResultTCB = "R^{\Red{\textsf{{\tiny TCB}}}}"

%format publishTCB = publish"^{\Red{\textsf{{\tiny TCB}}}}"
%format LIOTCB = "LIO^{\Red{\textsf{{\tiny TCB}}}}"
%format LabeledTCB = "Lb^{\Red{\textsf{{\tiny TCB}}}}"
%format LIORefTCB (s) = "Ref^{\Red{\textsf{{\tiny TCB}}}}_{"s"}"
%format LIORef(s) = "Ref_{"s"}"
%format TCB = "{}^{\Red{\textsf{{\tiny{TCB}}}}}"

%format LIOTCBEx = "LIO_{X}^{\Red{\textsf{{\tiny TCB}}}}"
%format LabeledTCBEx = "Lb_{X}^{\Red{\textsf{{\tiny TCB}}}}"

%format LIOTCB_b  = LIOTCB"_{"b"}"
%format LIOTCB_b1 = LIOTCB"_{"b1"}"
%format LIOTCB_b2 = LIOTCB"_{"b2"}"
%format LIOTCB_bi = LIOTCB"_{"b"_"i"}"
%format LIOTCB_b' = LIOTCB"_{"b'"}"
%format LIOTCB_b'' = LIOTCB"_{"b''"}"

%format LabeledTCB_b  = LabeledTCB"_{"b"}"
%format LabeledTCB_b1 = LabeledTCB"_{"b1"}"
%format LabeledTCB_b2 = LabeledTCB"_{"b2"}"
%format LabeledTCB_bi = LabeledTCB"_{"b"_"i"}"
%format LabeledTCB_b' = LabeledTCB"_{"b'"}"
%format LabeledTCB_b'' = LabeledTCB"_{"b''"}"

%format newLMVar = "\textbf{newLMVar}"
%format takeLMVar = "\textbf{takeLMVar}"
%format putLMVar = "\textbf{putLMVar}"

%format space = "{}"

%format atomicModifyRef (s) = "\textbf{atomicModifyRef}_{"s"}"
%format newRef (s)   = "\textbf{newRef}_{"s"}"
%format writeRef (s) = "\textbf{writeRef}_{"s"}"
%format readRef (s) = "\textbf{readRef}_{"s"}"
%format labelOf = "\textbf{labelOf}"
%format labelOfR (s) = labelOf"_{"s"}"
%format upgrade = "\textbf{upgrade}"
%format upgradeR = "\textbf{upgrade}_"S
%format label = "\textbf{label}"
%format unlabel = "\textbf{unlabel}"
%format toLabeled = "\textbf{toLabeled}"
%format toLabeled'
%format noToLabeled = "\hcancel{\textbf{toLabeled}\ t\ t}"
%format forkLIO = "\textbf{forkLIO}"
%format forkLIO'
%format withRefs = "\textbf{withRefs}_"S
%format waitLIO = "\textbf{waitLIO}"
%format upgradeM = "\textbf{upgradeStore}_"S
%format upgradeL (t) (l) = t"\Uparrow^{"l"}"
%format emptyset = "\emptyset"
%format @= = "\triangleq{}"
%format &= = "\cong_\textrm{$\not$ref}"

%format ex = "\xi"
%format ifcFail = ex"_{\tiny IFC}"

%format b1
%format b2

%format alpha = "\alpha"
%format alpha'

%format boxdot = "\boxdot"

%format tau = "\tau"
%format tau'
%format tau_1
%format tau_2
%format tau_3
%format tau1
%format tau2
%format tau3

%format t'
%format t''
%format t_1
%format t_2
%format t_3
%format t1
%format ti = t"_"i
%format ti' = t'"_"i
%format t_n = t"_"n
%format t2
%format t3
%format t1'
%format t2'
%format t3'
%format t1''
%format t2''
%format t3''

%format autofs = "\textsc{fs+au}"
%format S = "\textsc{fs}"
%format I = "\textsc{fi}"

%format m = "\mu"
%format m'
%format m''
%format m1
%format m2
%format m_alpha

%format mI = "\mu_"I
%format mI'
%format mI''
%format mI1
%format mI2

%format mS = "\mu_"S
%format mS'
%format mS''
%format mS1
%format mS2

%format ms = "\mu_s"
%format ms'
%format ms''
%format ms1
%format ms2

%format c = "\Sigma"
%format c'
%format c''
%format c'''
%format c1
%format c2
%format c1'
%format c2'

%format G = "\Gamma"
%format G'
%format G''
%format G'''
%format G1
%format G2

%format D = "\Delta"
%format D'
%format D''
%format D'''
%format D1
%format D2

%format k'
%format k''
%format k1
%format k2
%format knew = k"_\textrm{new}"
%format addrs (s) = addrs(s)
%format refs (s)  = addrs"^{-1}" (s)

%format a'
%format a''
%format a1
%format a2
%format a_n = a"_n"
%format a_i = a"_"i

%format v'
%format v''
%format v1
%format v2
%format v_n = v"_n"
%format v_i = v"_i"


%format when = "\textbf{when}"
%format unless = "\textbf{unless}"
%format \_ = \ {-\!\!\!\!-}_

%format set (s) ="\overline{{"s"}}"
%format nil = "\epsilon_{\,\overline{"tau", ...}}"


%% language
\newcommand{\Coloneqq}{::=} % txfonts
%format ::=     = "\Coloneqq"

%format fix      = "\mathbf{fix}"
%format return   = "\mathbf{return}"
%format getLabel = "\mathbf{getLabel}"
%format .       = "."
%format cdots   = "\cdots"
%format cdot    = "\cdot"
%format lop     = "\otimes"
%format mapsto  = "\mapsto"
%format element = "\in"
%format dom     = "\textrm{dom}"
%format and     = "\cap"
%format or      = "\cup"
%format merge   = "\!\!\triangleright\!\!"
%format E       = "\textbf{\Blue{E}}"
%format Ep      = "\Red{E}"

%format impl (x) (y) = "\llbracket " x "\rrbracket_{"I"}^{"y"}"
%format impl1 (x)  = "\llbracket " x "\rrbracket_{"I"}"


\newcommand{\dom}[1]{\ensuremath{{\textrm{dom}} #1}}
\newcommand{\fresh}[1]{\ensuremath{\textrm{fresh}(#1)}}
\newcommand{\update}[3]{\ensuremath{#1 [ #2 \mapsto #3 ]}}

%format (denot (a)) = "\llbracket " a "\rrbracket_{"lattice"}"
%format (denot_2 (a)) = "\llbracket " a "\rrbracket_{"lattice2"}"
%format conf (c) (t) = "\conf{"c"}{"t"}"
%format tconf (i) (s) (t) = "\tconf{"i"}{"s"}{"t"}"
%format thread (i) (s) (t) = "\thread{"i"}{"s"}{"t"}"
%format fresh (a) = "\fresh{"a"}"
%format update (m) (a) (t) = "\update{"m"}{"a"}{"t"}"


%values
\newcommand{\true}{\textsf{true}}
\newcommand{\false}{\textsf{false}}
\newcommand{\unit}{\textsf{()}}
\newcommand{\fix}[1]{\textsf{fix}\ #1}
\newcommand{\Labeled}[3]{\textsf{Labeled}\ensuremath{^{#1}}\ #2\ #3}
\newcommand{\LabeledX}[2]{\Labeled{\_}{#1}{#2}}
\newcommand{\LabeledO}[2]{\Labeled{}{#1}{#2}}
\newcommand{\LabeledF}[2]{\Labeled{\dagger}{#1}{#2}}
\newcommand{\LIORef}[2]{\textsf{LIORef}\ #1\ #2}
\newcommand{\LIO}[1]{{#1}^\textsf{LIO}}

\newcommand{\Ex}{e}
\newcommand{\Exception}[1]{{#1}^\textsf{LIOEx}}

%termms
\newcommand{\ifel}[3]{\textsf{if}\ #1\ \textsf{then}\ #2\ \textsf{else}\ #3}
\newcommand{\join}[2]{#1 \lub #2}
\newcommand{\meet}[2]{#1 \lub #2}
\newcommand{\canFlowTo}[2]{#1 \flows #2}
\newcommand{\return}[1]{\textsf{return}\ #1}
\newcommand{\bindSymbol}{\ensuremath{\gg\!\!\!=}}
%\newcommand{\bind}[2]{#1 \bindSymbol #2}
\newcommand{\getLabel}{\textsf{getLabel}}
\newcommand{\getClearance}{\textsf{getClearance}}
\newcommand{\llabel}[2]{\textsf{label}\ #1\ #2}
\newcommand{\labelOf}[1]{\textsf{labelOf}\ #1}
\newcommand{\unlabel}[1]{\textsf{unlabel}\ #1}
\newcommand{\toLabeled}[2]{\textsf{toLabeled}\ #1\ #2}
\newcommand{\lowerClr}[1]{\textsf{lowerClearance}\ #1}
\newcommand{\raiseLbl}[1]{\textsf{raiseLabel}\ #1}
\newcommand{\labelOfLIORef}[1]{\textsf{labelOfLIORef}\ #1}
\newcommand{\newLIORef}[2]{\textsf{newLIORef}\ #1\ #2}
\newcommand{\readLIORef}[1]{\textsf{readLIORef}\ #1}
\newcommand{\writeLIORef}[2]{\textsf{writeLIORef}\ #1\ #2}
\newcommand{\throwLIO}[1]{\textsf{throwLIO}\ {#1}}
\newcommand{\catchLIO}[2]{\textsf{catchLIO}\ #1\ #2}

% types:
\newcommand{\BoolT}{\textsf{Bool}}
\newcommand{\unitT}{\textsf{()}}
\newcommand{\LIOT}[1]{\textsf{LIO}\ #1}
\newcommand{\LabelT}{\textsf{Label}}
\newcommand{\LabeledT}[1]{\textsf{Labeled}\ #1}
\newcommand{\LIORefT}[1]{\textsf{LIORef}\ #1}
\newcommand{\ExceptionT}{\ensuremath{\mathsf{Exception}}}

%memory
\newcommand{\act}{k}

%

\newcommand{\ruleref}[1]{(\textsc{#1})}





% term erasure
%\newcommand{\hole}{\bullet}
%\newcommand{\eraseName}{\varepsilon}
%\newcommand{\erase}[2]{\eraseName_{#1}(#2)}


\newcommand{\coq}{\ensuremath{\star}}
\newcommand{\nocoq}{\textrm{\ding{45}}}


%%%
\newcommand{\conf}[2]{\langle #1 |inlinesep| #2\rangle}
\newcommand{\tconf}[3]{\{ #1, #2 |inlinesep| #3\}}
\newcommand{\thread}[3]{\langle #1, #2, #3\rangle}

%%
\newcommand{\lio}{\ensuremath{\lambda^{\textsf{\tiny LIO}}_{|lattice|}}}
\newcommand{\liofs}{\ensuremath{\lambda^{\textsf{\tiny LIO}}_{|lattice, S|}}}
\newcommand{\lioconc}{\ensuremath{\lambda^{\textsf{\tiny $\parallel$-LIO}}_{|lattice|}}}
\newcommand{\lioafs}{\ensuremath{\lambda^{\textsf{\tiny LIO}}_{|lattice,autofs|}}}
