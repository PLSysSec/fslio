\section{Concurrency}

In this section, we analyze our flow-sensitivity extensions in presence of
concurrency. We firstly give a brief introduction to a subset of the concurrent
version of |LIO|.
% which includes operations for creating threads and expressing
% communication among them.

\hl{To do}

\subsection{Flow-sensitive references}
In a sequential setting, the attack in Figure~\ref{fig:fs-attack} is disabled by
the enforcement presented in the previous section, allowing us to prove
termination-insensitive non-interference. However, as described before, the
concurrent version of |LIO| requires the property of
\emph{termination-sensitive} non-interference. In this section, we show ohow
threads and label changes on shared references jeopardizes security.  
Specifically, we present how to exploit the termination channel in concurrent 
|LIO|.

\begin{figure}
\begin{code}
do  forkLIO H $ -- Thread A
       do  v <- readLIORef secretM
          when v (readLIORef secretH)
    forkLIO H $ -- Thread B
       do  upgrade shared_ref M
           writeLIORef public True
\end{code}  
\caption{Flow-sensitive attack in a concurrent setting.\label{fig:fs-conc-attack}}
\end{figure}
Figure~\ref{fig:fs-conc-attack} shows the attack. This piece of code illustrates
that our approach for sequential |LIO| does not naturally generalize for
concurrency.  
%how to exploit the termination
%channel to leak information in this context. 
We assume that threads are interleaved so that thread A's code runs to
completion before thread B's code. Otherwise, it is enough to insert dummy
instructions before forking thread B. We also assume the standard three-point
lattice |low canFlowTo medium canFlowTo high|. Thread A firstly read a secret at
label |medium|, thereby upgrading |shared_ref| to that label. Depending on the
read value, the thread then reads a secret with label |high|, which further
upgrades |shared_ref| to |high|. Thread B, on the other hand, firstly try to
upgrade |shared_ref| to level |medium|. It is this instruction which exploits
the termination channel. If |secretM| was |False|, the upgrade operation
succeeds since |share_ref| is already at level |medium|. In contrast, if
|secretM| was |True|, the instruction fails due to |shared_ref| having the label
|high|. This implies that the operation that follows the upgrade instruction,
which writes a value to a public reference at level |low| (|writeLIORef public
True|), will either be executed or not depending on a value at level |medium|.
The fact of stopping thread B at different execution points, depending on
|secretM|, constitutes a termination leak. 

In general terms, the attack shows that threads, with different floating-labels,
might refer to the same shared flow-sensitive reference. If the reference is
upgraded in one thread based on some confidential data, then it might taint the
other ones when the reference is read. Such taints might then stop the execution
of the threads, which consequently could exploit the termination covert channel.

In order to address this attack, we can either remove shared state altogether,
or use the \emph{no-sensitive-upgrades} policy without explicit or automatic
upgrades. At the semantics level, restricting sharing is achieved when forking.

\hl{Pablo, can you put the rule here avoiding sharing?}

Once sharing is restricted, it is safe to upgrade flow-sensitive references as 
we did for the sequential setting of LIO. 

\hl{Ale: Not sure about the next paragraph, is it the automatically upgrade what 
does not work? I believe it is the upgrade, so no upgrade then of any kind}
The strategy of {\nsu} avoid the attack in Figure~\ref{fig:fs-conc-attack}.  The
reason for that is that |shared_ref| would not be \emph{automatically} upgraded
by thread A. Consequently, command |upgrade share_ref medium| succeeds and so
both threads would always run to completion, producing no leaks.


% Local Variables:
% TeX-master: "main.tex"
% TeX-command-default: "Make"
% End: